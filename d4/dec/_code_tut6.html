<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chi-Tech: Coding Tutorial 6 - Transport using WDD</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../Logo2_Small.bmp"/></td>
  <td id="projectalign">
   <div id="projectname">Chi-Tech
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d4/dec/_code_tut6.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Coding Tutorial 6 - Transport using WDD </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Table of contents</h2>
<ul>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec1">1 The multigroup Discrete Ordinates Equations</a></li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec2">2 The Diamond Difference Spatial Discretization</a><ul>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec2_1">2.1 The right hand side</a></li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec2_2">2.2 The left hand side</a></li>
</ul>
</li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec3">3 Getting the grid with additional preoperties</a></li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec4">4 Creating an angular quadrature</a></li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec5">5 Auxialiary items</a></li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec6">6 Defining a cell-by-cell sweep chunk</a></li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec7">7 Defining a sweep over all directions</a></li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec8">8 The Classic Richardson iterative scheme</a></li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6Sec9">9 Exporting only the scalar flux</a></li>
<li><a class="el" href="../../d4/dec/_code_tut6.html#CodeTut6SecX">The complete program</a></li>
</ul>
<h1><a class="anchor" id="CodeTut6Sec1"></a>
1 The multigroup Discrete Ordinates Equations</h1>
<p >In this tutorial we look at the multigroup discrete ordinates (DO) equations, otherwise known as the \( S_N \) equations. For a complete tutorial, on how these equations are derived, please consult <a href="https://github.com/doctor-janv/whitepapers/blob/main/ChiTech-LBS-TheoryManual/ChiTech-LBS-TheoryManual_v_1_13.pdf">this whitepaper</a>.</p>
<p >We start with the equations themselves </p><p class="formulaDsp">
\[ \biggr(\boldsymbol{\Omega}_n \boldsymbol{\cdot} \boldsymbol{\nabla} +\sigma_{tg} (\mathbf{x})\biggr) \psi_{gn} (\mathbf{x})= \sum_{m=0}^{N_m - 1} \frac{2\ell+1}{4\pi}Y_{\ell m^*}(\boldsymbol{\Omega}_n) \sum_{g&#39;=0}^{N_G-1} \biggr[ \sigma_{s\ell,g&#39;{\to}g} (\mathbf{x}) \ \phi_{mg&#39;}(\mathbf{x}) \biggr] + q_{g,n} (\mathbf{x}) \quad \quad \quad \mathbf{x}\in\mathcal{D} \]
</p>
 <p class="formulaDsp">
\[ \psi_{gn}(\mathbf{x}) =0 \quad \quad \quad \mathbf{x}\in\partial\mathcal{D} \]
</p>
<p> where the variables have the following meaning</p><ul>
<li>\( \boldsymbol{\Omega}_n \) is the \( n \)-th direction vector</li>
<li>\( \sigma_{tg} \) is the total interaction cross section for group \( g \)</li>
<li>\( \psi_{gn} \) is the angular flux for group \( g \) and direction \( n \)</li>
<li>\( Y_{\ell m^*} \) is the tesseral Spherical Harmonic function where \( (\ell, m^*) \) is mapped from \( m \)</li>
<li>\( \sigma_{sm,g&#39;{\to}g} \) is the scattering cross section for moment \( m \) scattering from group \( g&#39; \) to \( g \)</li>
<li>\( \phi_{mg} \) is the flux-moment for moment \( m \) group \( g \), computed from the angular quadrature <p class="formulaDsp">
\begin{align*} \phi_{gm}(\mathbf{x}) &amp;= \int_{4\pi} \psi_g(\mathbf{x},\boldsymbol{\Omega}) Y_{\ell m}(\boldsymbol{\Omega}) d\boldsymbol{\Omega}\\ &amp;=\sum_{n=0}^{N_D-1} w_n \ \psi_{gn}(\mathbf{x}) Y_{\ell m^*}(\boldsymbol{\Omega}_n) \end{align*}
</p>
</li>
<li>\( q_{g,n} \) is the angular material source for group \( g \) direction \( n \), normally defined as an isotropic source \( \frac{1}{4\pi} q_{g} \)</li>
</ul>
<p >The "angular quadrature" mentioned here contains considerable history. When the DO-method was still in it's infancy, most simulations were still one dimensional. In such cases the angular flux has no azimuthal dependence and the angular integrals reduce to <code>Gauss-Legendre</code> quadratures. Because the DO-method generally avoids the placement of a quadrature point on the \( \mu=0 \) plane, it was generally preferred to use quadratures with even-amounts of quadrature points. Because of this, people in the transport community typically referred to the DO-method as the \( S_N \) method with \( S_2 \) being the first even quadrature used, followed by \( S_4,\ S_8,\ \) etc.</p>
<p >In two and three dimensions, where one generally have dependence on both the azimuthal and polar directions (although 2D is symmetric in the polar angle), the nomenclature could be extended with the use of the "so-called" triangular quadratures. These type of quadratures placed ever decreasing amount of polar angles starting from the equator of the unit sphere towards the poles. Incidentally, if the number of polar angles per octant is \( N/2 \) then the azimuthal "level" closest to the equator will start with \( N/2 \) number of azimuthal angles. For example, an \( S_8 \) angular quadrature in 3D has 4 polar levels per octant, therefore the azimuthal angles would start at 4, then 3, then 2, then 1 at the polar-lelel closest to the pole.</p>
<p >The use of the triangular quadratures are considered to be quite antiquated. Some of the reasons for this includes the following:</p><ul>
<li>When more resolution in the azimuthal domain is required then a higher \( S_N \) order will unfortunately be accompanied by more polar angles.</li>
<li>In 2D, the polar dependence can accurately be captured with just a few polar angles, however, the azimuthal dependence may still be unresolved. Product quadratures are then best suited to place more azimuthal directions in the quadrature.</li>
<li>Generally, 3D simulations (e.g. reactor simulations) depend more strongly on the azimuthal directions than on the polar directions.</li>
</ul>
<p >In ChiTech we have a wide array of angular quadratures to choose from.</p>
<p >For this tutorial we will be looking at the following test problem </p><div class="image">
<img src="../../Tut6_problem.png" alt="" width="500px"/>
</div>
<p >The domain spans from -1 to +1 in both dimensions. We define a source in the sub-domain -0.5 to +0.5 in both dimensions. The source strength is 1 in group 0 only.</p>
<h1><a class="anchor" id="CodeTut6Sec2"></a>
2 The Diamond Difference Spatial Discretization</h1>
<p >The Diamond Difference (DD) spatial discretization is a precursor to the Weighted Diamond Difference (WDD) spatial discretization. Fundamentally, it is a Finite Volume based spatial discretization.</p>
<h2><a class="anchor" id="CodeTut6Sec2_1"></a>
2.1 The right hand side</h2>
<p >Since we are dealing with a FV discretization the values of cross sections, fluxes and sources are cell constant. Therefore, the RHS of the multigroup DO equations becomes </p><p class="formulaDsp">
\[ q_c^{rhs} = \sum_{m=0}^{N_m - 1} \frac{2\ell+1}{4\pi}Y_{\ell m^*}(\boldsymbol{\Omega}_n) \sum_{g&#39;=0}^{N_G-1} \biggr[ \sigma_{s\ell,g&#39;{\to}g,c} \ \phi_{mg&#39;,c} \biggr] + \frac{1}{4\pi} q_{g,c}. \]
</p>
<p> This representation is, however, not very practical and instead we choose to write it as </p><p class="formulaDsp">
\[ q_{c,g}^{rhs} = \sum_{m=0}^{N_m-1} M_{mn} q_{c,g}^{moms,m} \]
</p>
<p> where \( M_{mn} \) is called the Moment-To-Discrete operator (on a nodal level) and defined as </p><p class="formulaDsp">
\[ M_{mn} = \frac{2\ell+1}{4\pi}Y_{\ell m^*}(\boldsymbol{\Omega}_n) \]
</p>
<p> noting that \( (\ell,m^*) \) is mapped from \( m \). This operator can be precomputed once the angular quadrature is known. The other quantity introduced here, \( q_{c,g}^{moms} \), is called the source moments for cell \( c \) group \( g \) and is defined by </p><p class="formulaDsp">
\[ q_{c,g}^{moms,m} = \begin{cases} \sum_{g&#39;=0}^{N_G-1} \biggr[ \sigma_{s\ell,g&#39;{\to}g,c} \ \phi_{mg&#39;,c} \biggr] + q_{c,g} \quad \quad &amp;m=0,\\ \sum_{g&#39;=0}^{N_G-1} \biggr[ \sigma_{s\ell,g&#39;{\to}g,c} \ \phi_{mg&#39;,c} \biggr] \quad \quad &amp;m\ne 0 \end{cases} \]
</p>
<p >In the iterative schemes, that will be introduced later, we compute and store a vector of source moments for each iteration.</p>
<h2><a class="anchor" id="CodeTut6Sec2_2"></a>
2.2 The left hand side</h2>
<p >With the simplified definition of the RHS we now need to address the discretization of the divergence term in the DO equations.</p>
<p >The DD approximation uses convention as shown in the figure below </p><div class="image">
<img src="../../Tut6_orthoijk.png" alt="" width="700px"/>
</div>
<p >With this convention we've introduced nodes on the interstitial faces between cells. Suppressing, for the moment, direction and group indices, we can express the divergence term as </p><p class="formulaDsp">
\[ \boldsymbol{\Omega} \boldsymbol{\cdot} \boldsymbol{\nabla} \psi = \Omega_x \frac{\partial \psi}{\partial x} + \Omega_y \frac{\partial \psi}{\partial y} + \Omega_z \frac{\partial \psi}{\partial z}. \]
</p>
<p> We then introduce the approximation, e.g., in the x-dimension </p><p class="formulaDsp">
\[ \Omega_x \frac{\partial \psi}{\partial x} = \frac{\Omega_x}{\Delta x} (\psi_{i+\frac{1}{2}} - \psi_{i-\frac{1}{2}}) \]
</p>
<p> which, if done for all the dimensions, introduces up to 6 new variables into the equation. Fortunately, since we can apply upwinding, we can eliminate half of these with the closure relation </p><p class="formulaDsp">
\[ \psi_i = \frac{1}{2}(\psi_{i+\frac{1}{2}} + \psi_{i-\frac{1}{2}}), \]
</p>
<p> obviously extended to all dimensions. To comprehend this upwinding, consider the schematic below, showing the upwinding for different configurations of \( \boldsymbol{\Omega}_n \).</p>
<div class="image">
<img src="../../Tut6_upwinding.png" alt="" width="500px"/>
</div>
<p >With upwinding defined we can re-express the upwinded angular flux as \( \psi_{us,x} \) being either \( \psi_{i+\frac{1}{2}} \) or \( \psi_{i-\frac{1}{2}} \) depending on the sign of \( \Omega_x \). The \( \psi_{us,x} \) of the current cell would then be the downstream flux, \( \psi_{ds,x} \) of the adjacent cell at the interstitial face. With some manipulation we arrive at the following equations to solve the current cell's \( \psi \):</p>
<div class="image">
<img src="../../Tut6_123D.png" alt="" width="500px"/>
</div>
<p >as well as the following equations to obtain its downstream angular flux: </p><p class="formulaDsp">
\begin{align*} \psi_{ds,x} &amp;= 2\psi - \psi_{us,x} \\ \psi_{ds,y} &amp;= 2\psi - \psi_{us,y} \\ \psi_{ds,z} &amp;= 2\psi - \psi_{us,z} \\ \end{align*}
</p>
<p >The solution procedure, per cell, is therefore to first grab \( \psi_{us} \) as either the upstream cell's \( \psi_{ds} \) or from the upstream boundary condition. Then to solve for the cell \( \psi \). Then to compute \( \psi_{ds} \).</p>
<p >The obvious difficulty now is to loop through the cells in such a way that the upstream relationships, with respect to a given \( \boldsymbol{\Omega}_n \), is maintained. This process is known as <b>sweeping</b>. And for orthogonal grids it looks like shown in the figure below</p>
<div class="image">
<img src="../../Tut6_sweeping.png" alt="" width="700px"/>
</div>
<h1><a class="anchor" id="CodeTut6Sec3"></a>
3 Getting the grid with additional preoperties</h1>
<p >We get the grid in the same fashion as we did in all the previous tutorial, however, this time need to get some additional information since we will use it during the sweep.</p>
<p >We define the following code once we obtained a reference to the grid </p><div class="fragment"><div class="line"><span class="comment">//============================================= Make Orthogonal mapping</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>  ijk_info         = grid.GetIJKInfo();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; ijk_mapping      = grid.MakeIJKToGlobalIDMapping();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>  cell_ortho_sizes = grid.MakeCellOrthoSizes();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> Nx = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(ijk_info[0]);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> Ny = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(ijk_info[1]);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> Nz = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(ijk_info[2]);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> Dim1 = <a class="code hl_enumvalue" href="../../d0/d81/namespacechi__mesh.html#ad98d4e91589e7fa4e04bd70274068362a73bd95bf58ed2c1cd1ef2f4257fc3975">chi_mesh::DIMENSION_1</a>;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> Dim2 = <a class="code hl_enumvalue" href="../../d0/d81/namespacechi__mesh.html#ad98d4e91589e7fa4e04bd70274068362ac5d5534358879a033391a7c43407a246">chi_mesh::DIMENSION_2</a>;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> Dim3 = <a class="code hl_enumvalue" href="../../d0/d81/namespacechi__mesh.html#ad98d4e91589e7fa4e04bd70274068362af15b5a9461f9a446c9117b100d8e11f2">chi_mesh::DIMENSION_3</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span>    dimension = 0;</div>
<div class="line"><span class="keywordflow">if</span> (grid.Attributes() &amp; Dim1) dimension = 1;</div>
<div class="line"><span class="keywordflow">if</span> (grid.Attributes() &amp; Dim2) dimension = 2;</div>
<div class="line"><span class="keywordflow">if</span> (grid.Attributes() &amp; Dim3) dimension = 3;</div>
<div class="ttc" id="anamespacechi__mesh_html_ad98d4e91589e7fa4e04bd70274068362a73bd95bf58ed2c1cd1ef2f4257fc3975"><div class="ttname"><a href="../../d0/d81/namespacechi__mesh.html#ad98d4e91589e7fa4e04bd70274068362a73bd95bf58ed2c1cd1ef2f4257fc3975">chi_mesh::DIMENSION_1</a></div><div class="ttdeci">@ DIMENSION_1</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dcb/chi__mesh_8h_source.html#l00072">chi_mesh.h:72</a></div></div>
<div class="ttc" id="anamespacechi__mesh_html_ad98d4e91589e7fa4e04bd70274068362ac5d5534358879a033391a7c43407a246"><div class="ttname"><a href="../../d0/d81/namespacechi__mesh.html#ad98d4e91589e7fa4e04bd70274068362ac5d5534358879a033391a7c43407a246">chi_mesh::DIMENSION_2</a></div><div class="ttdeci">@ DIMENSION_2</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dcb/chi__mesh_8h_source.html#l00073">chi_mesh.h:73</a></div></div>
<div class="ttc" id="anamespacechi__mesh_html_ad98d4e91589e7fa4e04bd70274068362af15b5a9461f9a446c9117b100d8e11f2"><div class="ttname"><a href="../../d0/d81/namespacechi__mesh.html#ad98d4e91589e7fa4e04bd70274068362af15b5a9461f9a446c9117b100d8e11f2">chi_mesh::DIMENSION_3</a></div><div class="ttdeci">@ DIMENSION_3</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dcb/chi__mesh_8h_source.html#l00074">chi_mesh.h:74</a></div></div>
</div><!-- fragment --><p> The structure <code>ijk_info</code> holds an array holding the number of cells in x,y and z. The structure <code>ijk_mapping</code> holds a mapping, given a cell's ijk index, to the linear global mapping. The structure <code>cell_ortho_size</code> contains a <code>std::vector</code> of cell \( \Delta x \), \( \Delta y \) and \( \Delta z \). We finally also assign the dimensionality of the mesh to an integer <code>dimension</code>.</p>
<h1><a class="anchor" id="CodeTut6Sec4"></a>
4 Creating an angular quadrature</h1>
<p >The base class for angular quadratures is <code><a class="el" href="../../d8/dd9/classchi__math_1_1_angular_quadrature.html">chi_math::AngularQuadrature</a></code>. </p><div class="fragment"><div class="line"><span class="comment">//============================================= Make an angular quadrature</span></div>
<div class="line">std::shared_ptr&lt;chi_math::AngularQuadrature&gt; quadrature;</div>
<div class="line"><span class="keywordflow">if</span> (dimension == 1)</div>
<div class="line">  quadrature = std::make_shared&lt;chi_math::AngularQuadratureProdGL&gt;(8);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimension == 2)</div>
<div class="line">{</div>
<div class="line">  quadrature = std::make_shared&lt;chi_math::AngularQuadratureProdGLC&gt;(8,8);</div>
<div class="line">  quadrature-&gt;OptimizeForPolarSymmetry(4.0*M_PI);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimension == 3)</div>
<div class="line">  quadrature = std::make_shared&lt;chi_math::AngularQuadratureProdGLC&gt;(8,8);</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <span class="keywordflow">throw</span> std::logic_error(fname + <span class="stringliteral">&quot;Error with the dimensionality &quot;</span></div>
<div class="line">                                 <span class="stringliteral">&quot;of the mesh.&quot;</span>);</div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Quadrature created.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >Depending on the dimensionality of the grid we instate a different quadrature set. For example, in one dimension we instantiate the Gauss-Legendre quadrature encapsulated in a product quadrature, <code><a class="el" href="../../d5/d32/classchi__math_1_1_angular_quadrature_prod_g_l.html">chi_math::AngularQuadratureProdGL</a></code>. </p><div class="fragment"><div class="line">quadrature = std::make_shared&lt;chi_math::AngularQuadratureProdGL&gt;(8);</div>
</div><!-- fragment --><p> where the parameter is the number of polar angles per hemisphere.</p>
<p >In two and three dimensions we instantiate the Gauss-Legendre-Chebyshev quadrature encapsulated in a product quadrature, <code><a class="el" href="../../d6/d28/classchi__math_1_1_angular_quadrature_prod_g_l_c.html">chi_math::AngularQuadratureProdGLC</a></code>. </p><div class="fragment"><div class="line">quadrature = std::make_shared&lt;chi_math::AngularQuadratureProdGLC&gt;(8,8);</div>
</div><!-- fragment --><p> A GLC quadrature is essentially an evenly spaced quadrature in the azimuthal space and a regular Legendre spacing in the polar space. The parameters are the number of azimuthal angles per octant and the number of polar angles per octant.</p>
<p >For the 2D case, which has polar symmetry, we can modify the quadrature to only contain the directions in the upper hemisphere. We do this as </p><div class="fragment"><div class="line">quadrature = std::make_shared&lt;chi_math::AngularQuadratureProdGLC&gt;(8,8);</div>
<div class="line">quadrature-&gt;OptimizeForPolarSymmetry(4.0*M_PI);</div>
</div><!-- fragment --><p> The argument for <code>OptimizeForPolarSymmetry</code> is the normalization factor to use when normalizing the quadrature.</p>
<p >Since we now have the angular quadrature we can compute the Moment-To-Discrete and Discrete-To-Moment operator. </p><div class="fragment"><div class="line"><span class="comment">//============================================= Set/Get params</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> scat_order = 1;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_groups = 20;</div>
<div class="line"> </div>
<div class="line">quadrature-&gt;BuildMomentToDiscreteOperator(scat_order,dimension);</div>
<div class="line">quadrature-&gt;BuildDiscreteToMomentOperator(scat_order,dimension);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; m2d = quadrature-&gt;GetMomentToDiscreteOperator();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; d2m = quadrature-&gt;GetDiscreteToMomentOperator();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; m_ell_em_map = quadrature-&gt;GetMomentToHarmonicsIndexMap();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_moments = m_ell_em_map.size();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_dirs = quadrature-&gt;omegas.size();</div>
<div class="line"> </div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;End Set/Get params.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Num Moments: &quot;</span> &lt;&lt; num_moments &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Notice we also obtained the mapping from \( m \) to \( (\ell,m^*) \) in the structure <code>m_ell_em_map</code> which contains a list of <code><a class="el" href="../../d7/d0d/structchi__math_1_1_angular_quadrature_1_1_harmonic_indices.html">chi_math::AngularQuadrature::HarmonicIndices</a></code>.</p>
<h1><a class="anchor" id="CodeTut6Sec5"></a>
5 Auxialiary items</h1>
<p >We define the auxiliary items as follows </p><div class="fragment"><div class="line"><span class="comment">//============================================= Make Unknown Managers</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> VecN = <a class="code hl_enumvalue" href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1dad7dc5b5f08aa4bc980c2f7e92a9046d4">chi_math::UnknownType::VECTOR_N</a>;</div>
<div class="line"><span class="keyword">using</span> Unknown = <a class="code hl_class" href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a>;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Unknown&gt; phi_uks(num_moments, Unknown(VecN, num_groups));</div>
<div class="line">std::vector&lt;Unknown&gt; psi_uks(num_dirs,    Unknown(VecN, num_groups));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="../../d9/da7/classchi__math_1_1_unknown_manager.html">chi_math::UnknownManager</a> phi_uk_man(phi_uks);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="../../d9/da7/classchi__math_1_1_unknown_manager.html">chi_math::UnknownManager</a> psi_uk_man(psi_uks);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_local_phi_dofs = sdm.GetNumLocalDOFs(phi_uk_man);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_local_psi_dofs = sdm.GetNumLocalDOFs(psi_uk_man);</div>
<div class="line"> </div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;End ukmanagers.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//============================================= Make XSs</span></div>
<div class="line">chi_physics::TransportCrossSections xs;</div>
<div class="line">xs.MakeFromCHIxsFile(<span class="stringliteral">&quot;tests/xs_graphite_pure.cxs&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//============================================= Initializes vectors</span></div>
<div class="line">std::vector&lt;double&gt; phi_old(num_local_phi_dofs,0.0);</div>
<div class="line">std::vector&lt;double&gt; psi(num_local_psi_dofs, 0.0);</div>
<div class="line"><span class="keyword">auto</span> source_moments = phi_old;</div>
<div class="line"><span class="keyword">auto</span> phi_new        = phi_old;</div>
<div class="line"><span class="keyword">auto</span> q_source       = phi_old;</div>
<div class="line"> </div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;End vectors.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//============================================= Make material source term</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell : grid.local_cells)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cc = cell.centroid;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_mapping = sdm.GetCellMapping(cell);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_nodes = cell_mapping.NumNodes();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (cc.x &lt; 0.5 and cc.y &lt; 0.5 and cc.z &lt; 0.5 and</div>
<div class="line">      cc.x &gt;-0.5 and cc.y &gt;-0.5 and cc.z &gt;-0.5)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> int64_t dof_map = sdm.MapDOFLocal(cell,i,phi_uk_man,0,0);</div>
<div class="line"> </div>
<div class="line">      q_source[dof_map] = 1.0;</div>
<div class="line">    }<span class="comment">//for node i</span></div>
<div class="line">  }<span class="comment">//if inside box</span></div>
<div class="line">}<span class="comment">//for cell</span></div>
<div class="ttc" id="aclasschi__math_1_1_unknown_html"><div class="ttname"><a href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a></div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d3b/unknown__manager_8h_source.html#l00031">unknown_manager.h:32</a></div></div>
<div class="ttc" id="aclasschi__math_1_1_unknown_manager_html"><div class="ttname"><a href="../../d9/da7/classchi__math_1_1_unknown_manager.html">chi_math::UnknownManager</a></div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d3b/unknown__manager_8h_source.html#l00122">unknown_manager.h:123</a></div></div>
<div class="ttc" id="anamespacechi__math_html_ad4724873fa5ae74b39c4657aa4f53d1dad7dc5b5f08aa4bc980c2f7e92a9046d4"><div class="ttname"><a href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1dad7dc5b5f08aa4bc980c2f7e92a9046d4">chi_math::UnknownType::VECTOR_N</a></div><div class="ttdeci">@ VECTOR_N</div></div>
</div><!-- fragment --><p >First is the unknown managers for \( \phi \) and \( \psi \). Then transport cross sections via the class <code>chi_physics::TransportCrossSections</code>.</p>
<p >We then define the unknown vectors. </p><div class="fragment"><div class="line"><span class="comment">//============================================= Initializes vectors</span></div>
<div class="line">std::vector&lt;double&gt; phi_old(num_local_phi_dofs,0.0);</div>
<div class="line">std::vector&lt;double&gt; psi(num_local_psi_dofs, 0.0);</div>
<div class="line"><span class="keyword">auto</span> source_moments = phi_old;</div>
<div class="line"><span class="keyword">auto</span> phi_new        = phi_old;</div>
<div class="line"><span class="keyword">auto</span> q_source       = phi_old;</div>
<div class="line"> </div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;End vectors.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >Finally, we hardcode the source distribution </p><div class="fragment"><div class="line"><span class="comment">//============================================= Make material source term</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell : grid.local_cells)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cc = cell.centroid;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_mapping = sdm.GetCellMapping(cell);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_nodes = cell_mapping.NumNodes();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (cc.x &lt; 0.5 and cc.y &lt; 0.5 and cc.z &lt; 0.5 and</div>
<div class="line">      cc.x &gt;-0.5 and cc.y &gt;-0.5 and cc.z &gt;-0.5)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> int64_t dof_map = sdm.MapDOFLocal(cell,i,phi_uk_man,0,0);</div>
<div class="line"> </div>
<div class="line">      q_source[dof_map] = 1.0;</div>
<div class="line">    }<span class="comment">//for node i</span></div>
<div class="line">  }<span class="comment">//if inside box</span></div>
<div class="line">}<span class="comment">//for cell</span></div>
</div><!-- fragment --><h1><a class="anchor" id="CodeTut6Sec6"></a>
6 Defining a cell-by-cell sweep chunk</h1>
<div class="fragment"><div class="line"><span class="comment">//============================================= Define sweep chunk</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="../../d2/d5d/classchi__data__types_1_1_n_d_array.html">chi_data_types::NDArray&lt;double&gt;</a> <a class="code hl_typedef" href="../../dd/dbc/namespacechi__unit__tests.html#a0f4c88de2a2904b2e2891be50c163d8e">IJKArrayDbl</a>;</div>
<div class="line"><a class="code hl_typedef" href="../../dd/dbc/namespacechi__unit__tests.html#a0f4c88de2a2904b2e2891be50c163d8e">IJKArrayDbl</a> psi_ds_x(std::array&lt;int64_t,4&gt;{Nx,Ny,Nz,num_groups});</div>
<div class="line"><a class="code hl_typedef" href="../../dd/dbc/namespacechi__unit__tests.html#a0f4c88de2a2904b2e2891be50c163d8e">IJKArrayDbl</a> psi_ds_y(std::array&lt;int64_t,4&gt;{Nx,Ny,Nz,num_groups});</div>
<div class="line"><a class="code hl_typedef" href="../../dd/dbc/namespacechi__unit__tests.html#a0f4c88de2a2904b2e2891be50c163d8e">IJKArrayDbl</a> psi_ds_z(std::array&lt;int64_t,4&gt;{Nx,Ny,Nz,num_groups});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_struct" href="../../dd/d54/structchi__mesh_1_1_vector3.html">chi_mesh::Vector3</a> Vec3;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="../../d3/dfd/classchi__mesh_1_1sweep__management_1_1_sweep_chunk.html">SweepChunk</a> = [&amp;ijk_info, &amp;ijk_mapping, &amp;cell_ortho_sizes, <span class="comment">//ortho-quantities</span></div>
<div class="line">                   &amp;grid, &amp;sdm,</div>
<div class="line">                   &amp;num_moments,</div>
<div class="line">                   &amp;phi_uk_man, &amp;psi_uk_man,</div>
<div class="line">                   &amp;m2d,&amp;d2m,</div>
<div class="line">                   &amp;phi_new, &amp;source_moments, &amp;psi,</div>
<div class="line">                   &amp;psi_ds_x, &amp;psi_ds_y, &amp;psi_ds_z]</div>
<div class="line">  (<span class="keyword">const</span> std::array&lt;int64_t,3&gt;&amp; ijk,</div>
<div class="line">   <span class="keyword">const</span> Vec3&amp; omega,</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">size_t</span> d,</div>
<div class="line">   <span class="keyword">const</span> chi_physics::TransportCrossSections&amp; cell_xs)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>   cell_global_id = ijk_mapping.MapNDtoLin(ijk[1],ijk[0],ijk[2]);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp;  cell           = grid.cells[cell_global_id];</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>   cell_local_id  = cell.local_id;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp;  cell_mapping   = sdm.GetCellMapping(cell);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_ortho_size = cell_ortho_sizes[cell_local_id];</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> dx = cell_ortho_size.x;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> dy = cell_ortho_size.y;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> dz = cell_ortho_size.z;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; zero_vector(num_groups,0.0);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>* psi_us_x = zero_vector.data();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>* psi_us_y = zero_vector.data();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>* psi_us_z = zero_vector.data();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> i = ijk[0]; <span class="keyword">const</span> <span class="keyword">auto</span> Nx = ijk_info[0];</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> j = ijk[1]; <span class="keyword">const</span> <span class="keyword">auto</span> Ny = ijk_info[1];</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> k = ijk[2]; <span class="keyword">const</span> <span class="keyword">auto</span> Nz = ijk_info[2];</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (omega.x &gt; 0.0 and i &gt; 0     ) psi_us_x = &amp;psi_ds_x(i-1,j  ,k  ,0);</div>
<div class="line">  <span class="keywordflow">if</span> (omega.x &lt; 0.0 and i &lt; (Nx-1)) psi_us_x = &amp;psi_ds_x(i+1,j  ,k  ,0);</div>
<div class="line">  <span class="keywordflow">if</span> (omega.y &gt; 0.0 and j &gt; 0     ) psi_us_y = &amp;psi_ds_y(i  ,j-1,k  ,0);</div>
<div class="line">  <span class="keywordflow">if</span> (omega.y &lt; 0.0 and j &lt; (Ny-1)) psi_us_y = &amp;psi_ds_y(i  ,j+1,k  ,0);</div>
<div class="line">  <span class="keywordflow">if</span> (omega.z &gt; 0.0 and k &gt; 0     ) psi_us_z = &amp;psi_ds_z(i  ,j  ,k-1,0);</div>
<div class="line">  <span class="keywordflow">if</span> (omega.z &lt; 0.0 and k &lt; (Nz-1)) psi_us_z = &amp;psi_ds_z(i  ,j  ,k+1,0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> g=0; g&lt;num_groups; ++g)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">double</span> rhs = 0.0;</div>
<div class="line">    <span class="comment">//Source moments</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m&lt;num_moments; ++m)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> int64_t dof_map = sdm.MapDOFLocal(cell,0,phi_uk_man,m,g);</div>
<div class="line">      rhs += source_moments[dof_map]*m2d[m][d];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (Nx &gt; 1) rhs += 2.0*std::fabs(omega.x)*psi_us_x[g]/dx;</div>
<div class="line">    <span class="keywordflow">if</span> (Ny &gt; 1) rhs += 2.0*std::fabs(omega.y)*psi_us_y[g]/dy;</div>
<div class="line">    <span class="keywordflow">if</span> (Nz &gt; 1) rhs += 2.0*std::fabs(omega.z)*psi_us_z[g]/dz;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> lhs = cell_xs.sigma_t[g];</div>
<div class="line">    <span class="keywordflow">if</span> (Nx &gt; 1) lhs += 2.0*std::fabs(omega.x)/dx;</div>
<div class="line">    <span class="keywordflow">if</span> (Ny &gt; 1) lhs += 2.0*std::fabs(omega.y)/dy;</div>
<div class="line">    <span class="keywordflow">if</span> (Nz &gt; 1) lhs += 2.0*std::fabs(omega.z)/dz;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> psi_ijk = rhs/lhs;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Accumulate flux-moments</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m&lt;num_moments; ++m)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> int64_t dof_map = sdm.MapDOFLocal(cell,0,phi_uk_man,m,g);</div>
<div class="line">      phi_new[dof_map] += d2m[m][d]*psi_ijk;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Save angular fluxes</span></div>
<div class="line">    <span class="keyword">const</span> int64_t psi_map = sdm.MapDOFLocal(cell,0,psi_uk_man,d,g);</div>
<div class="line">    psi[psi_map] = psi_ijk;</div>
<div class="line"> </div>
<div class="line">    psi_ds_x(i,j,k,g) = 2.0*psi_ijk - psi_us_x[g];</div>
<div class="line">    psi_ds_y(i,j,k,g) = 2.0*psi_ijk - psi_us_y[g];</div>
<div class="line">    psi_ds_z(i,j,k,g) = 2.0*psi_ijk - psi_us_z[g];</div>
<div class="line">  }<span class="comment">//for g</span></div>
<div class="line">};</div>
<div class="ttc" id="aclasschi__data__types_1_1_n_d_array_html"><div class="ttname"><a href="../../d2/d5d/classchi__data__types_1_1_n_d_array.html">chi_data_types::NDArray</a></div><div class="ttdef"><b>Definition:</b> <a href="../../de/d01/ndarray_8h_source.html#l00015">ndarray.h:16</a></div></div>
<div class="ttc" id="aclasschi__mesh_1_1sweep__management_1_1_sweep_chunk_html"><div class="ttname"><a href="../../d3/dfd/classchi__mesh_1_1sweep__management_1_1_sweep_chunk.html">chi_mesh::sweep_management::SweepChunk</a></div><div class="ttdef"><b>Definition:</b> <a href="../../d1/dc1/sweepchunk__base_8h_source.html#l00010">sweepchunk_base.h:11</a></div></div>
<div class="ttc" id="anamespacechi__unit__tests_html_a0f4c88de2a2904b2e2891be50c163d8e"><div class="ttname"><a href="../../dd/dbc/namespacechi__unit__tests.html#a0f4c88de2a2904b2e2891be50c163d8e">chi_unit_tests::IJKArrayDbl</a></div><div class="ttdeci">chi_data_types::NDArray&lt; double &gt; IJKArrayDbl</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d88/test__02a__wdd__ijk__sweep_8cc_source.html#l00016">test_02a_wdd_ijk_sweep.cc:16</a></div></div>
<div class="ttc" id="astructchi__mesh_1_1_vector3_html"><div class="ttname"><a href="../../dd/d54/structchi__mesh_1_1_vector3.html">chi_mesh::Vector3</a></div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d7f/chi__meshvector_8h_source.html#l00018">chi_meshvector.h:19</a></div></div>
</div><!-- fragment --><p >The first portion of the chunk is obtaining all the relevant cell information </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>   cell_global_id = ijk_mapping.MapNDtoLin(ijk[1],ijk[0],ijk[2]);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;  cell           = grid.cells[cell_global_id];</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>   cell_local_id  = cell.local_id;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;  cell_mapping   = sdm.GetCellMapping(cell);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_ortho_size = cell_ortho_sizes[cell_local_id];</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> dx = cell_ortho_size.x;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> dy = cell_ortho_size.y;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> dz = cell_ortho_size.z;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> i = ijk[0]; <span class="keyword">const</span> <span class="keyword">auto</span> Nx = ijk_info[0];</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> j = ijk[1]; <span class="keyword">const</span> <span class="keyword">auto</span> Ny = ijk_info[1];</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> k = ijk[2]; <span class="keyword">const</span> <span class="keyword">auto</span> Nz = ijk_info[2];</div>
</div><!-- fragment --><p >Thereafter we determine the upstream fluxes from the general downstream \( \psi \) structures. These data structures are multidimensional arrays <code><a class="el" href="../../d2/d5d/classchi__data__types_1_1_n_d_array.html">chi_data_types::NDArray</a></code> which are used to store each cell's downstream components. These arrays are indexed with ijk indices making them easy to use in our orthogonal mesh setting. </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; zero_vector(num_groups,0.0);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>* psi_us_x = zero_vector.data();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>* psi_us_y = zero_vector.data();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>* psi_us_z = zero_vector.data();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (omega.x &gt; 0.0 and i &gt; 0     ) psi_us_x = &amp;psi_ds_x(i-1,j  ,k  ,0);</div>
<div class="line"><span class="keywordflow">if</span> (omega.x &lt; 0.0 and i &lt; (Nx-1)) psi_us_x = &amp;psi_ds_x(i+1,j  ,k  ,0);</div>
<div class="line"><span class="keywordflow">if</span> (omega.y &gt; 0.0 and j &gt; 0     ) psi_us_y = &amp;psi_ds_y(i  ,j-1,k  ,0);</div>
<div class="line"><span class="keywordflow">if</span> (omega.y &lt; 0.0 and j &lt; (Ny-1)) psi_us_y = &amp;psi_ds_y(i  ,j+1,k  ,0);</div>
<div class="line"><span class="keywordflow">if</span> (omega.z &gt; 0.0 and k &gt; 0     ) psi_us_z = &amp;psi_ds_z(i  ,j  ,k-1,0);</div>
<div class="line"><span class="keywordflow">if</span> (omega.z &lt; 0.0 and k &lt; (Nz-1)) psi_us_z = &amp;psi_ds_z(i  ,j  ,k+1,0);</div>
</div><!-- fragment --><p >Finally, we loop over each group then construct and solve the relevant equations.</p>
<p >First we develop the angular source from the source moments </p><p class="formulaDsp">
\[ q_{c,g}^{rhs} = \sum_{m=0}^{N_m-1} M_{mn} q_{c,g}^{moms,m} \]
</p>
 <div class="fragment"><div class="line"><span class="keywordtype">double</span> rhs = 0.0;</div>
<div class="line"><span class="comment">//Source moments</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m&lt;num_moments; ++m)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> int64_t dof_map = sdm.MapDOFLocal(cell,0,phi_uk_man,m,g);</div>
<div class="line">  rhs += source_moments[dof_map]*m2d[m][d];</div>
<div class="line">}</div>
</div><!-- fragment --><p >Thereafter we construct and solve the equation for \( \psi \), </p><div class="image">
<img src="../../Tut6_123D.png" alt="" width="500px"/>
</div>
<p> for which we have the code </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (Nx &gt; 1) rhs += 2.0*std::fabs(omega.x)*psi_us_x[g]/dx;</div>
<div class="line"><span class="keywordflow">if</span> (Ny &gt; 1) rhs += 2.0*std::fabs(omega.y)*psi_us_y[g]/dy;</div>
<div class="line"><span class="keywordflow">if</span> (Nz &gt; 1) rhs += 2.0*std::fabs(omega.z)*psi_us_z[g]/dz;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> lhs = cell_xs.sigma_t[g];</div>
<div class="line"><span class="keywordflow">if</span> (Nx &gt; 1) lhs += 2.0*std::fabs(omega.x)/dx;</div>
<div class="line"><span class="keywordflow">if</span> (Ny &gt; 1) lhs += 2.0*std::fabs(omega.y)/dy;</div>
<div class="line"><span class="keywordflow">if</span> (Nz &gt; 1) lhs += 2.0*std::fabs(omega.z)/dz;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> psi_ijk = rhs/lhs;</div>
</div><!-- fragment --><p >Once we have psi we can contribute to the flux moments </p><p class="formulaDsp">
\[ \phi_{\ell m^*} =\sum_n w_n Y_{\ell m^*}(\boldsymbol{\Omega}_n) \psi_n \]
</p>
<p> which maps to </p><p class="formulaDsp">
\begin{align*} \phi_m &amp;= \sum_n w_n Y_m (\boldsymbol{\Omega}_n) \psi_n \\ &amp;= \sum_n D_{mn} \psi_n \end{align*}
</p>
<p> where \( D_{mn} \) is the Discrete-To-Moment operator. We do the above with the following code </p><div class="fragment"><div class="line"><span class="comment">//Accumulate flux-moments</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m&lt;num_moments; ++m)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> int64_t dof_map = sdm.MapDOFLocal(cell,0,phi_uk_man,m,g);</div>
<div class="line">  phi_new[dof_map] += d2m[m][d]*psi_ijk;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Next we store all the angular flux </p><div class="fragment"><div class="line"><span class="comment">//Save angular fluxes</span></div>
<div class="line"><span class="keyword">const</span> int64_t psi_map = sdm.MapDOFLocal(cell,0,psi_uk_man,d,g);</div>
<div class="line">psi[psi_map] = psi_ijk;</div>
<div class="line"> </div>
<div class="line">psi_ds_x(i,j,k,g) = 2.0*psi_ijk - psi_us_x[g];</div>
<div class="line">psi_ds_y(i,j,k,g) = 2.0*psi_ijk - psi_us_y[g];</div>
<div class="line">psi_ds_z(i,j,k,g) = 2.0*psi_ijk - psi_us_z[g];</div>
</div><!-- fragment --><h1><a class="anchor" id="CodeTut6Sec7"></a>
7 Defining a sweep over all directions</h1>
<p >Next we define a routine that will sweep through cells with the correct upwinding structure for all the directions in the quadrature. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> Sweep = [&amp;num_dirs,&amp;quadrature,Nx,Ny,Nz,&amp;<a class="code hl_typedef" href="../../d9/df7/lbs_d_o__01__main__initialize_8cc.html#adfad77f405a91e0c24b4bed78523652d">SweepChunk</a>,&amp;xs]()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d=0; d&lt;num_dirs; ++d)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;omega = quadrature-&gt;omegas[d];</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;weight = quadrature-&gt;weights[d];</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;int64_t&gt; iorder, jorder, korder;</div>
<div class="line">    <span class="keywordflow">if</span> (omega.x &gt; 0.0) iorder = chi_math::Range&lt;int64_t&gt;(0, Nx);</div>
<div class="line">    <span class="keywordflow">else</span>               iorder = chi_math::Range&lt;int64_t&gt;(Nx - 1, -1, -1);</div>
<div class="line">    <span class="keywordflow">if</span> (omega.y &gt; 0.0) jorder = chi_math::Range&lt;int64_t&gt;(0, Ny);</div>
<div class="line">    <span class="keywordflow">else</span>               jorder = chi_math::Range&lt;int64_t&gt;(Ny - 1, -1, -1);</div>
<div class="line">    <span class="keywordflow">if</span> (omega.z &gt; 0.0) korder = chi_math::Range&lt;int64_t&gt;(0, Nz);</div>
<div class="line">    <span class="keywordflow">else</span>               korder = chi_math::Range&lt;int64_t&gt;(Nz - 1, -1, -1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i: iorder)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> j: jorder)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> k: korder)</div>
<div class="line">          <a class="code hl_typedef" href="../../d9/df7/lbs_d_o__01__main__initialize_8cc.html#adfad77f405a91e0c24b4bed78523652d">SweepChunk</a>({i,j,k}, omega, d, xs);</div>
<div class="line">  }<span class="comment">//for d</span></div>
<div class="line">};</div>
<div class="ttc" id="albs_d_o__01__main__initialize_8cc_html_adfad77f405a91e0c24b4bed78523652d"><div class="ttname"><a href="../../d9/df7/lbs_d_o__01__main__initialize_8cc.html#adfad77f405a91e0c24b4bed78523652d">SweepChunk</a></div><div class="ttdeci">chi_mesh::sweep_management::SweepChunk SweepChunk</div><div class="ttdef"><b>Definition:</b> <a href="../../d9/df7/lbs_d_o__01__main__initialize_8cc_source.html#l00010">lbsDO_01_main_initialize.cc:10</a></div></div>
</div><!-- fragment --><p> This kind of code, for the sweep ordering, will only work for orthogonal meshes hence why this tutorial is based on orthogonal meshes.</p>
<h1><a class="anchor" id="CodeTut6Sec8"></a>
8 The Classic Richardson iterative scheme</h1>
<p >Yup, as easy as this: </p><div class="fragment"><div class="line"><span class="comment">//============================================= Classic Richardson iteration</span></div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Starting iterations&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iter=0; iter&lt;200; ++iter)</div>
<div class="line">{</div>
<div class="line">  phi_new.assign(phi_new.size(), 0.0);</div>
<div class="line">  <span class="comment">//Build rhs</span></div>
<div class="line">  source_moments = <a class="code hl_function" href="../../d0/d68/namespacechi__unit__sim__tests.html#a15826c4853d6ae31074cfd0901702d69">SetSource</a>(grid,sdm,phi_uk_man,</div>
<div class="line">                             q_source,phi_old,xs,m_ell_em_map);</div>
<div class="line">  Sweep();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> rel_change = <a class="code hl_function" href="../../d0/d68/namespacechi__unit__sim__tests.html#a4ec383a71de8faee1ccf06fc95860c3a">ComputeRelativePWChange</a>(grid,sdm,phi_uk_man,</div>
<div class="line">                                                    phi_new, phi_old);</div>
<div class="line"> </div>
<div class="line">  std::stringstream outstr;</div>
<div class="line">  outstr &lt;&lt; <span class="stringliteral">&quot;Iteration &quot;</span> &lt;&lt; std::setw(5) &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">char</span> buffer[100];</div>
<div class="line">    sprintf(buffer, <span class="stringliteral">&quot;%11.3e\n&quot;</span>, rel_change);</div>
<div class="line">    outstr &lt;&lt; buffer;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; outstr.str();</div>
<div class="line"> </div>
<div class="line">  phi_old = phi_new;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (rel_change &lt; 1.0e-6 and iter &gt; 0)</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">}<span class="comment">//for iteration</span></div>
<div class="ttc" id="anamespacechi__unit__sim__tests_html_a15826c4853d6ae31074cfd0901702d69"><div class="ttname"><a href="../../d0/d68/namespacechi__unit__sim__tests.html#a15826c4853d6ae31074cfd0901702d69">chi_unit_sim_tests::SetSource</a></div><div class="ttdeci">std::vector&lt; double &gt; SetSource(const chi_mesh::MeshContinuum &amp;grid, const chi_math::SpatialDiscretization &amp;sdm, const chi_math::UnknownManager &amp;phi_uk_man, const std::vector&lt; double &gt; &amp;q_source, const std::vector&lt; double &gt; &amp;phi_old, const chi_physics::SingleStateMGXS &amp;xs, const std::vector&lt; YlmIndices &gt; &amp;m_ell_em_map)</div><div class="ttdef"><b>Definition:</b> <a href="../../da/dc0/simtest__06__wdd_8cc_source.html#l00394">simtest_06_wdd.cc:394</a></div></div>
<div class="ttc" id="anamespacechi__unit__sim__tests_html_a4ec383a71de8faee1ccf06fc95860c3a"><div class="ttname"><a href="../../d0/d68/namespacechi__unit__sim__tests.html#a4ec383a71de8faee1ccf06fc95860c3a">chi_unit_sim_tests::ComputeRelativePWChange</a></div><div class="ttdeci">double ComputeRelativePWChange(const chi_mesh::MeshContinuum &amp;grid, const chi_math::SpatialDiscretization &amp;sdm, const chi_math::UnknownManager &amp;phi_uk_man, const std::vector&lt; double &gt; &amp;in_phi_new, const std::vector&lt; double &gt; &amp;in_phi_old)</div><div class="ttdef"><b>Definition:</b> <a href="../../da/dc0/simtest__06__wdd_8cc_source.html#l00339">simtest_06_wdd.cc:339</a></div></div>
</div><!-- fragment --><p >Notice here we have defined two routines: </p><div class="fragment"><div class="line">std::vector&lt;double&gt; <a class="code hl_function" href="../../d0/d68/namespacechi__unit__sim__tests.html#a15826c4853d6ae31074cfd0901702d69">SetSource</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html">chi_mesh::MeshContinuum</a>&amp; grid,</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html">chi_math::SpatialDiscretization</a>&amp; sdm,</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/da7/classchi__math_1_1_unknown_manager.html">chi_math::UnknownManager</a>&amp; phi_uk_man,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt;&amp; q_source,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt;&amp; phi_old,</div>
<div class="line">    <span class="keyword">const</span> chi_physics::TransportCrossSections&amp; xs,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;YlmIndices&gt;&amp; m_ell_em_map)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_local_phi_dofs = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a2ebdc6713acf43edb3ae74ac4146e4c3">GetNumLocalDOFs</a>(phi_uk_man);</div>
<div class="line">  std::vector&lt;double&gt; source_moments(num_local_phi_dofs, 0.0);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_moments = phi_uk_man.unknowns.size();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_groups = phi_uk_man.unknowns.front().num_components;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell : grid.<a class="code hl_variable" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a227b26a2cc0e920fff45d31ed171e9cc">local_cells</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_mapping = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a417f70f19dc1ac883ed7410ab62cfc1e">GetCellMapping</a>(cell);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_nodes = cell_mapping.<a class="code hl_function" href="../../d8/d08/classchi__math_1_1_cell_mapping.html#a6809460aa9d92037fbf0bf18b76c9946">NumNodes</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; S = xs.transfer_matrices;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m&lt;num_moments; ++m)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> int64_t dof_map = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#ab1c21223f44661906bc3223676b6cd84">MapDOFLocal</a>(cell,i,phi_uk_man,m,0);</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> ell = m_ell_em_map[m].ell;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> g=0; g&lt;num_groups; ++g)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">//Fixed source</span></div>
<div class="line">          source_moments[dof_map + g] = q_source[dof_map + g];</div>
<div class="line"> </div>
<div class="line">          <span class="comment">//Inscattering</span></div>
<div class="line">          <span class="keywordflow">if</span> (ell &lt; S.size())</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordtype">double</span> inscat_g = 0.0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [row_g, gprime, sigma_sm] : S[ell].Row(g))</div>
<div class="line">              inscat_g += sigma_sm * phi_old[dof_map + gprime];</div>
<div class="line"> </div>
<div class="line">            source_moments[dof_map + g] += inscat_g;</div>
<div class="line">          }</div>
<div class="line">        }<span class="comment">//for g</span></div>
<div class="line">      }<span class="comment">//for m</span></div>
<div class="line">    }<span class="comment">//for node i</span></div>
<div class="line">  }<span class="comment">//for cell</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> source_moments;</div>
<div class="line">}</div>
<div class="ttc" id="aclasschi__math_1_1_cell_mapping_html_a6809460aa9d92037fbf0bf18b76c9946"><div class="ttname"><a href="../../d8/d08/classchi__math_1_1_cell_mapping.html#a6809460aa9d92037fbf0bf18b76c9946">chi_math::CellMapping::NumNodes</a></div><div class="ttdeci">size_t NumNodes() const</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/da6/cell__mapping__base_8h_source.html#l00063">cell_mapping_base.h:63</a></div></div>
<div class="ttc" id="aclasschi__math_1_1_spatial_discretization_html"><div class="ttname"><a href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html">chi_math::SpatialDiscretization</a></div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d28/spatial__discretization_8h_source.html#l00018">spatial_discretization.h:19</a></div></div>
<div class="ttc" id="aclasschi__math_1_1_spatial_discretization_html_a2ebdc6713acf43edb3ae74ac4146e4c3"><div class="ttname"><a href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a2ebdc6713acf43edb3ae74ac4146e4c3">chi_math::SpatialDiscretization::GetNumLocalDOFs</a></div><div class="ttdeci">virtual size_t GetNumLocalDOFs(const UnknownManager &amp;unknown_manager) const =0</div></div>
<div class="ttc" id="aclasschi__math_1_1_spatial_discretization_html_a417f70f19dc1ac883ed7410ab62cfc1e"><div class="ttname"><a href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a417f70f19dc1ac883ed7410ab62cfc1e">chi_math::SpatialDiscretization::GetCellMapping</a></div><div class="ttdeci">const CellMapping &amp; GetCellMapping(const chi_mesh::Cell &amp;cell) const</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d3f/spatial__discretization__00_8cc_source.html#l00005">spatial_discretization_00.cc:5</a></div></div>
<div class="ttc" id="aclasschi__math_1_1_spatial_discretization_html_ab1c21223f44661906bc3223676b6cd84"><div class="ttname"><a href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#ab1c21223f44661906bc3223676b6cd84">chi_math::SpatialDiscretization::MapDOFLocal</a></div><div class="ttdeci">virtual int64_t MapDOFLocal(const chi_mesh::Cell &amp;cell, unsigned int node, const UnknownManager &amp;unknown_manager, unsigned int unknown_id, unsigned int component) const =0</div></div>
<div class="ttc" id="aclasschi__mesh_1_1_mesh_continuum_html"><div class="ttname"><a href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html">chi_mesh::MeshContinuum</a></div><div class="ttdef"><b>Definition:</b> <a href="../../d0/db3/chi__meshcontinuum_8h_source.html#l00034">chi_meshcontinuum.h:35</a></div></div>
<div class="ttc" id="aclasschi__mesh_1_1_mesh_continuum_html_a227b26a2cc0e920fff45d31ed171e9cc"><div class="ttname"><a href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a227b26a2cc0e920fff45d31ed171e9cc">chi_mesh::MeshContinuum::local_cells</a></div><div class="ttdeci">LocalCellHandler local_cells</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/db3/chi__meshcontinuum_8h_source.html#l00049">chi_meshcontinuum.h:49</a></div></div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code hl_function" href="../../d0/d68/namespacechi__unit__sim__tests.html#a4ec383a71de8faee1ccf06fc95860c3a">ComputeRelativePWChange</a>(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html">chi_mesh::MeshContinuum</a>&amp; grid,</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html">chi_math::SpatialDiscretization</a>&amp; sdm,</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="../../d9/da7/classchi__math_1_1_unknown_manager.html">chi_math::UnknownManager</a>&amp; phi_uk_man,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt;&amp; in_phi_new,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt;&amp; in_phi_old</div>
<div class="line">  )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">double</span> pw_change = 0.0;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_moments = phi_uk_man.unknowns.size();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_groups = phi_uk_man.unknowns.front().num_components;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell : grid.<a class="code hl_variable" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a227b26a2cc0e920fff45d31ed171e9cc">local_cells</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_mapping = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a417f70f19dc1ac883ed7410ab62cfc1e">GetCellMapping</a>(cell);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_nodes = cell_mapping.<a class="code hl_function" href="../../d8/d08/classchi__math_1_1_cell_mapping.html#a6809460aa9d92037fbf0bf18b76c9946">NumNodes</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">//Get scalar moments</span></div>
<div class="line">      <span class="keyword">const</span> int64_t m0_map = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#ab1c21223f44661906bc3223676b6cd84">MapDOFLocal</a>(cell,i,phi_uk_man,0,0);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>* phi_new_m0 = &amp;in_phi_new[m0_map];</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>* phi_old_m0 = &amp;in_phi_old[m0_map];</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m&lt;num_moments; ++m)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> int64_t m_map = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#ab1c21223f44661906bc3223676b6cd84">MapDOFLocal</a>(cell,i,phi_uk_man,m,0);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>* phi_new_m = &amp;in_phi_new[m_map];</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>* phi_old_m = &amp;in_phi_old[m_map];</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> g=0; g&lt;num_groups; ++g)</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> abs_phi_new_g_m0 = std::fabs(phi_new_m0[g]);</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> abs_phi_old_g_m0 = std::fabs(phi_old_m0[g]);</div>
<div class="line"> </div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> max_denominator = std::max(abs_phi_new_g_m0,</div>
<div class="line">                                                  abs_phi_old_g_m0);</div>
<div class="line"> </div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> delta_phi = std::fabs(phi_new_m[g] - phi_old_m[g]);</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">if</span> (max_denominator &gt;= std::numeric_limits&lt;double&gt;::min())</div>
<div class="line">            pw_change = std::max(delta_phi/max_denominator,pw_change);</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            pw_change = std::max(delta_phi,pw_change);</div>
<div class="line">        }<span class="comment">//for g</span></div>
<div class="line">      }<span class="comment">//for m</span></div>
<div class="line">    }<span class="comment">//for i</span></div>
<div class="line">  }<span class="comment">//for cell</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> pw_change;</div>
<div class="line">}</div>
</div><!-- fragment --><p >The <code>SetSource</code> routine populates the <code>source_moments</code> vector, while the <code>ComputeRelativePWChange</code> routine computes a modified version of the \( L_\infty \) norm by compute the maximum change relative to the scalar moment flux on each node-group pair.</p>
<h1><a class="anchor" id="CodeTut6Sec9"></a>
9 Exporting only the scalar flux</h1>
<p >We finally want to export the scalar flux to VTK. We have a problem though. The scalar flux is mixed in within the other flux moments. Therefore we need to copy the scalar flux, with the <code>phi_old</code> vector, which has the unknown structure define by <code>phi_uk_man</code> to another vector <code>m0_phi</code> with a different unknown structure. We do this with the following code </p><div class="fragment"><div class="line"><span class="comment">//============================================= Localize zeroth moment</span></div>
<div class="line"><span class="comment">//This routine extracts a single moment vector</span></div>
<div class="line"><span class="comment">//from the vector that contains multiple moments</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="../../d9/da7/classchi__math_1_1_unknown_manager.html">chi_math::UnknownManager</a> m0_uk_man(</div>
<div class="line">  {<a class="code hl_class" href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a>(<a class="code hl_enumvalue" href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1dad7dc5b5f08aa4bc980c2f7e92a9046d4">chi_math::UnknownType::VECTOR_N</a>,num_groups)});</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_m0_dofs = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a2ebdc6713acf43edb3ae74ac4146e4c3">GetNumLocalDOFs</a>(m0_uk_man);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; m0_phi(num_m0_dofs, 0.0);</div>
<div class="line"> </div>
<div class="line">sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a7a3255f84a521d4fccfaf9a72b415af3">CopyVectorWithUnknownScope</a>(phi_old,     <span class="comment">//from vector</span></div>
<div class="line">                               m0_phi,      <span class="comment">//to vector</span></div>
<div class="line">                               phi_uk_man,  <span class="comment">//from dof-structure</span></div>
<div class="line">                               0,           <span class="comment">//from unknown-id</span></div>
<div class="line">                               m0_uk_man,   <span class="comment">//to dof-structure</span></div>
<div class="line">                               0);          <span class="comment">//to unknown-id</span></div>
<div class="ttc" id="aclasschi__math_1_1_spatial_discretization_html_a7a3255f84a521d4fccfaf9a72b415af3"><div class="ttname"><a href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a7a3255f84a521d4fccfaf9a72b415af3">chi_math::SpatialDiscretization::CopyVectorWithUnknownScope</a></div><div class="ttdeci">void CopyVectorWithUnknownScope(const std::vector&lt; double &gt; &amp;from_vector, std::vector&lt; double &gt; &amp;to_vector, const UnknownManager &amp;from_vec_uk_structure, unsigned int from_vec_uk_id, const UnknownManager &amp;to_vec_uk_structure, unsigned int to_vec_uk_id) const</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/dd5/spatial__discretization__05_8cc_source.html#l00117">spatial_discretization_05.cc:117</a></div></div>
</div><!-- fragment --><p> This code should be self explanatory.</p>
<p >Finally we create, update and export the field function like we did with the other tutorials. </p><div class="fragment"><div class="line"><span class="comment">//============================================= Create Field Function</span></div>
<div class="line"><span class="keyword">auto</span> phi_ff = std::make_shared&lt;chi_physics::FieldFunction&gt;(</div>
<div class="line">  <span class="stringliteral">&quot;Phi&quot;</span>,                                           <span class="comment">//Text name</span></div>
<div class="line">  sdm_ptr,                                         <span class="comment">//Spatial Discr.</span></div>
<div class="line">  <a class="code hl_class" href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a>(<a class="code hl_enumvalue" href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1dad7dc5b5f08aa4bc980c2f7e92a9046d4">chi_math::UnknownType::VECTOR_N</a>,num_groups) <span class="comment">//Unknown</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">phi_ff-&gt;UpdateFieldVector(m0_phi);</div>
<div class="line">phi_ff-&gt;ExportToVTK(<span class="stringliteral">&quot;SimTest_06_WDD&quot;</span>);</div>
</div><!-- fragment --><p >The solution is shown below: </p><div class="image">
<img src="../../Tut6_solutiong0.png" alt="" width="700px"/>
</div>
<p> Notice the blocky appearance, a consequence of the finite volume discretization.</p>
<h1><a class="anchor" id="CodeTut6SecX"></a>
The complete program</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d3/db2/chi__runtime_8h.html">chi_runtime.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../dc/d75/chi__log_8h.html">chi_log.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../df/d98/chi__meshhandler_8h.html">ChiMesh/MeshHandler/chi_meshhandler.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d0/db3/chi__meshcontinuum_8h.html">ChiMesh/MeshContinuum/chi_meshcontinuum.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../de/d50/fv_8h.html">ChiMath/SpatialDiscretization/FiniteVolume/fv.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d5/d27/angular__quadrature__base_8h.html">ChiMath/Quadratures/angular_quadrature_base.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../da/daf/angular__product__quadrature_8h.html">ChiMath/Quadratures/angular_product_quadrature.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d4/d1c/chi__math__range_8h.html">ChiMath/chi_math_range.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;ChiPhysics/FieldFunction/fieldfunction2.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ChiPhysics/PhysicsMaterial/transportxsections/material_property_transportxsections.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../de/d01/ndarray_8h.html">ChiDataTypes/ndarray.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../d4/dca/chi__tech__main_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  chi::Initialize(argc,argv);</div>
<div class="line">  chi::RunBatch(argc, argv);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string fname = <span class="stringliteral">&quot;Tutorial_06&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (chi::mpi.process_count != 1)</div>
<div class="line">    <span class="keywordflow">throw</span> std::logic_error(fname + <span class="stringliteral">&quot;: Is serial only.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Get grid</span></div>
<div class="line">  <span class="keyword">auto</span> grid_ptr = <a class="code hl_function" href="../../d0/d81/namespacechi__mesh.html#addcd6899961d4c527b02c33708a7941f">chi_mesh::GetCurrentHandler</a>().<a class="code hl_function" href="../../d2/d10/classchi__mesh_1_1_mesh_handler.html#aa87887c1a76634cb07134b5faa1e3587">GetGrid</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; grid = *grid_ptr;</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Global num cells: &quot;</span> &lt;&lt; grid.<a class="code hl_function" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#aeb466c76d1b4d532fe8bc5fc7765a338">GetGlobalNumberOfCells</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Make Orthogonal mapping</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>  ijk_info         = grid.<a class="code hl_function" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a5cb74fab0769b9fda964b5429623d04a">GetIJKInfo</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; ijk_mapping      = grid.<a class="code hl_function" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a6ff14aae03e8c78ca276c9f2884bcd98">MakeIJKToGlobalIDMapping</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>  cell_ortho_sizes = grid.<a class="code hl_function" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a66224c8024c8e1e395389dd8ccd547c1">MakeCellOrthoSizes</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> Nx = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(ijk_info[0]);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> Ny = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(ijk_info[1]);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> Nz = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(ijk_info[2]);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> Dim1 = <a class="code hl_enumvalue" href="../../d0/d81/namespacechi__mesh.html#ad98d4e91589e7fa4e04bd70274068362a73bd95bf58ed2c1cd1ef2f4257fc3975">chi_mesh::DIMENSION_1</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> Dim2 = <a class="code hl_enumvalue" href="../../d0/d81/namespacechi__mesh.html#ad98d4e91589e7fa4e04bd70274068362ac5d5534358879a033391a7c43407a246">chi_mesh::DIMENSION_2</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> Dim3 = <a class="code hl_enumvalue" href="../../d0/d81/namespacechi__mesh.html#ad98d4e91589e7fa4e04bd70274068362af15b5a9461f9a446c9117b100d8e11f2">chi_mesh::DIMENSION_3</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span>    dimension = 0;</div>
<div class="line">  <span class="keywordflow">if</span> (grid.<a class="code hl_function" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a15eed36e4da5d55ac9ad26d6a37a7a72">Attributes</a>() &amp; Dim1) dimension = 1;</div>
<div class="line">  <span class="keywordflow">if</span> (grid.<a class="code hl_function" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a15eed36e4da5d55ac9ad26d6a37a7a72">Attributes</a>() &amp; Dim2) dimension = 2;</div>
<div class="line">  <span class="keywordflow">if</span> (grid.<a class="code hl_function" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a15eed36e4da5d55ac9ad26d6a37a7a72">Attributes</a>() &amp; Dim3) dimension = 3;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Make SDM</span></div>
<div class="line">  <span class="keyword">typedef</span> std::shared_ptr&lt;chi_math::SpatialDiscretization&gt; <a class="code hl_typedef" href="../../dc/d58/namespacechi__math.html#ab6754b3179f7dbf965932210273fead7">SDMPtr</a>;</div>
<div class="line">  <a class="code hl_typedef" href="../../dc/d58/namespacechi__math.html#ab6754b3179f7dbf965932210273fead7">SDMPtr</a> sdm_ptr = <a class="code hl_function" href="../../d0/d9a/classchi__math_1_1_spatial_discretization___f_v.html#aef2abe8e2064b84e29d87a2b2b2f984d">chi_math::SpatialDiscretization_FV::New</a>(grid_ptr);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; sdm = *sdm_ptr;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; OneDofPerNode = sdm.<a class="code hl_variable" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#ab44301c258e4b6921f7afad19e355746">UNITARY_UNKNOWN_MANAGER</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_local_nodes = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a2ebdc6713acf43edb3ae74ac4146e4c3">GetNumLocalDOFs</a>(OneDofPerNode);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_globl_nodes = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a04c0c7022de9c74ac6a807398afec030">GetNumGlobalDOFs</a>(OneDofPerNode);</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Num local nodes: &quot;</span> &lt;&lt; num_local_nodes;</div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Num globl nodes: &quot;</span> &lt;&lt; num_globl_nodes;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Make an angular quadrature</span></div>
<div class="line">  std::shared_ptr&lt;chi_math::AngularQuadrature&gt; quadrature;</div>
<div class="line">  <span class="keywordflow">if</span> (dimension == 1)</div>
<div class="line">    quadrature = std::make_shared&lt;chi_math::AngularQuadratureProdGL&gt;(8);</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimension == 2)</div>
<div class="line">  {</div>
<div class="line">    quadrature = std::make_shared&lt;chi_math::AngularQuadratureProdGLC&gt;(8,8);</div>
<div class="line">    quadrature-&gt;OptimizeForPolarSymmetry(4.0*M_PI);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimension == 3)</div>
<div class="line">    quadrature = std::make_shared&lt;chi_math::AngularQuadratureProdGLC&gt;(8,8);</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">throw</span> std::logic_error(fname + <span class="stringliteral">&quot;Error with the dimensionality &quot;</span></div>
<div class="line">                                   <span class="stringliteral">&quot;of the mesh.&quot;</span>);</div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Quadrature created.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Set/Get params</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> scat_order = 1;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_groups = 20;</div>
<div class="line"> </div>
<div class="line">  quadrature-&gt;BuildMomentToDiscreteOperator(scat_order,dimension);</div>
<div class="line">  quadrature-&gt;BuildDiscreteToMomentOperator(scat_order,dimension);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; m2d = quadrature-&gt;GetMomentToDiscreteOperator();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; d2m = quadrature-&gt;GetDiscreteToMomentOperator();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; m_ell_em_map = quadrature-&gt;GetMomentToHarmonicsIndexMap();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_moments = m_ell_em_map.size();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_dirs = quadrature-&gt;omegas.size();</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;End Set/Get params.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Num Moments: &quot;</span> &lt;&lt; num_moments &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Make Unknown Managers</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> VecN = <a class="code hl_enumvalue" href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1dad7dc5b5f08aa4bc980c2f7e92a9046d4">chi_math::UnknownType::VECTOR_N</a>;</div>
<div class="line">  <span class="keyword">using</span> Unknown = <a class="code hl_class" href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a>;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Unknown&gt; phi_uks(num_moments, Unknown(VecN, num_groups));</div>
<div class="line">  std::vector&lt;Unknown&gt; psi_uks(num_dirs,    Unknown(VecN, num_groups));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="../../d9/da7/classchi__math_1_1_unknown_manager.html">chi_math::UnknownManager</a> phi_uk_man(phi_uks);</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="../../d9/da7/classchi__math_1_1_unknown_manager.html">chi_math::UnknownManager</a> psi_uk_man(psi_uks);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_local_phi_dofs = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a2ebdc6713acf43edb3ae74ac4146e4c3">GetNumLocalDOFs</a>(phi_uk_man);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_local_psi_dofs = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a2ebdc6713acf43edb3ae74ac4146e4c3">GetNumLocalDOFs</a>(psi_uk_man);</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;End ukmanagers.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Make XSs</span></div>
<div class="line">  chi_physics::TransportCrossSections xs;</div>
<div class="line">  xs.MakeFromCHIxsFile(<span class="stringliteral">&quot;tests/xs_graphite_pure.cxs&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Initializes vectors</span></div>
<div class="line">  std::vector&lt;double&gt; phi_old(num_local_phi_dofs,0.0);</div>
<div class="line">  std::vector&lt;double&gt; psi(num_local_psi_dofs, 0.0);</div>
<div class="line">  <span class="keyword">auto</span> source_moments = phi_old;</div>
<div class="line">  <span class="keyword">auto</span> phi_new        = phi_old;</div>
<div class="line">  <span class="keyword">auto</span> q_source       = phi_old;</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;End vectors.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Make material source term</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell : grid.<a class="code hl_variable" href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a227b26a2cc0e920fff45d31ed171e9cc">local_cells</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cc = cell.centroid;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_mapping = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a417f70f19dc1ac883ed7410ab62cfc1e">GetCellMapping</a>(cell);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_nodes = cell_mapping.<a class="code hl_function" href="../../d8/d08/classchi__math_1_1_cell_mapping.html#a6809460aa9d92037fbf0bf18b76c9946">NumNodes</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cc.x &lt; 0.5 and cc.y &lt; 0.5 and cc.z &lt; 0.5 and</div>
<div class="line">        cc.x &gt;-0.5 and cc.y &gt;-0.5 and cc.z &gt;-0.5)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> int64_t dof_map = sdm.<a class="code hl_function" href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#ab1c21223f44661906bc3223676b6cd84">MapDOFLocal</a>(cell,i,phi_uk_man,0,0);</div>
<div class="line"> </div>
<div class="line">        q_source[dof_map] = 1.0;</div>
<div class="line">      }<span class="comment">//for node i</span></div>
<div class="line">    }<span class="comment">//if inside box</span></div>
<div class="line">  }<span class="comment">//for cell</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Define sweep chunk</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="../../d2/d5d/classchi__data__types_1_1_n_d_array.html">chi_data_types::NDArray&lt;double&gt;</a> <a class="code hl_typedef" href="../../dd/dbc/namespacechi__unit__tests.html#a0f4c88de2a2904b2e2891be50c163d8e">IJKArrayDbl</a>;</div>
<div class="line">  <a class="code hl_typedef" href="../../dd/dbc/namespacechi__unit__tests.html#a0f4c88de2a2904b2e2891be50c163d8e">IJKArrayDbl</a> psi_ds_x(std::array&lt;int64_t,4&gt;{Nx,Ny,Nz,num_groups});</div>
<div class="line">  <a class="code hl_typedef" href="../../dd/dbc/namespacechi__unit__tests.html#a0f4c88de2a2904b2e2891be50c163d8e">IJKArrayDbl</a> psi_ds_y(std::array&lt;int64_t,4&gt;{Nx,Ny,Nz,num_groups});</div>
<div class="line">  <a class="code hl_typedef" href="../../dd/dbc/namespacechi__unit__tests.html#a0f4c88de2a2904b2e2891be50c163d8e">IJKArrayDbl</a> psi_ds_z(std::array&lt;int64_t,4&gt;{Nx,Ny,Nz,num_groups});</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="../../dd/d54/structchi__mesh_1_1_vector3.html">chi_mesh::Vector3</a> Vec3;</div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_class" href="../../d3/dfd/classchi__mesh_1_1sweep__management_1_1_sweep_chunk.html">SweepChunk</a> = [&amp;ijk_info, &amp;ijk_mapping, &amp;cell_ortho_sizes, <span class="comment">//ortho-quantities</span></div>
<div class="line">                     &amp;grid, &amp;sdm,</div>
<div class="line">                     &amp;num_moments,</div>
<div class="line">                     &amp;phi_uk_man, &amp;psi_uk_man,</div>
<div class="line">                     &amp;m2d,&amp;d2m,</div>
<div class="line">                     &amp;phi_new, &amp;source_moments, &amp;psi,</div>
<div class="line">                     &amp;psi_ds_x, &amp;psi_ds_y, &amp;psi_ds_z]</div>
<div class="line">    (<span class="keyword">const</span> std::array&lt;int64_t,3&gt;&amp; ijk,</div>
<div class="line">     <span class="keyword">const</span> Vec3&amp; omega,</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">size_t</span> d,</div>
<div class="line">     <span class="keyword">const</span> chi_physics::TransportCrossSections&amp; cell_xs)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>   cell_global_id = ijk_mapping.MapNDtoLin(ijk[1],ijk[0],ijk[2]);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp;  cell           = grid.cells[cell_global_id];</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>   cell_local_id  = cell.local_id;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp;  cell_mapping   = sdm.GetCellMapping(cell);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_ortho_size = cell_ortho_sizes[cell_local_id];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> dx = cell_ortho_size.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> dy = cell_ortho_size.y;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> dz = cell_ortho_size.z;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> i = ijk[0]; <span class="keyword">const</span> <span class="keyword">auto</span> Nx = ijk_info[0];</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> j = ijk[1]; <span class="keyword">const</span> <span class="keyword">auto</span> Ny = ijk_info[1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> k = ijk[2]; <span class="keyword">const</span> <span class="keyword">auto</span> Nz = ijk_info[2];</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; zero_vector(num_groups,0.0);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>* psi_us_x = zero_vector.data();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>* psi_us_y = zero_vector.data();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>* psi_us_z = zero_vector.data();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (omega.x &gt; 0.0 and i &gt; 0     ) psi_us_x = &amp;psi_ds_x(i-1,j  ,k  ,0);</div>
<div class="line">    <span class="keywordflow">if</span> (omega.x &lt; 0.0 and i &lt; (Nx-1)) psi_us_x = &amp;psi_ds_x(i+1,j  ,k  ,0);</div>
<div class="line">    <span class="keywordflow">if</span> (omega.y &gt; 0.0 and j &gt; 0     ) psi_us_y = &amp;psi_ds_y(i  ,j-1,k  ,0);</div>
<div class="line">    <span class="keywordflow">if</span> (omega.y &lt; 0.0 and j &lt; (Ny-1)) psi_us_y = &amp;psi_ds_y(i  ,j+1,k  ,0);</div>
<div class="line">    <span class="keywordflow">if</span> (omega.z &gt; 0.0 and k &gt; 0     ) psi_us_z = &amp;psi_ds_z(i  ,j  ,k-1,0);</div>
<div class="line">    <span class="keywordflow">if</span> (omega.z &lt; 0.0 and k &lt; (Nz-1)) psi_us_z = &amp;psi_ds_z(i  ,j  ,k+1,0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> g=0; g&lt;num_groups; ++g)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">double</span> rhs = 0.0;</div>
<div class="line">      <span class="comment">//Source moments</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m&lt;num_moments; ++m)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> int64_t dof_map = sdm.MapDOFLocal(cell,0,phi_uk_man,m,g);</div>
<div class="line">        rhs += source_moments[dof_map]*m2d[m][d];</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (Nx &gt; 1) rhs += 2.0*std::fabs(omega.x)*psi_us_x[g]/dx;</div>
<div class="line">      <span class="keywordflow">if</span> (Ny &gt; 1) rhs += 2.0*std::fabs(omega.y)*psi_us_y[g]/dy;</div>
<div class="line">      <span class="keywordflow">if</span> (Nz &gt; 1) rhs += 2.0*std::fabs(omega.z)*psi_us_z[g]/dz;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> lhs = cell_xs.sigma_t[g];</div>
<div class="line">      <span class="keywordflow">if</span> (Nx &gt; 1) lhs += 2.0*std::fabs(omega.x)/dx;</div>
<div class="line">      <span class="keywordflow">if</span> (Ny &gt; 1) lhs += 2.0*std::fabs(omega.y)/dy;</div>
<div class="line">      <span class="keywordflow">if</span> (Nz &gt; 1) lhs += 2.0*std::fabs(omega.z)/dz;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> psi_ijk = rhs/lhs;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//Accumulate flux-moments</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m&lt;num_moments; ++m)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> int64_t dof_map = sdm.MapDOFLocal(cell,0,phi_uk_man,m,g);</div>
<div class="line">        phi_new[dof_map] += d2m[m][d]*psi_ijk;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//Save angular fluxes</span></div>
<div class="line">      <span class="keyword">const</span> int64_t psi_map = sdm.MapDOFLocal(cell,0,psi_uk_man,d,g);</div>
<div class="line">      psi[psi_map] = psi_ijk;</div>
<div class="line"> </div>
<div class="line">      psi_ds_x(i,j,k,g) = 2.0*psi_ijk - psi_us_x[g];</div>
<div class="line">      psi_ds_y(i,j,k,g) = 2.0*psi_ijk - psi_us_y[g];</div>
<div class="line">      psi_ds_z(i,j,k,g) = 2.0*psi_ijk - psi_us_z[g];</div>
<div class="line">    }<span class="comment">//for g</span></div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Define sweep for all dirs</span></div>
<div class="line">  <span class="keyword">auto</span> Sweep = [&amp;num_dirs,&amp;quadrature,Nx,Ny,Nz,&amp;<a class="code hl_typedef" href="../../d9/df7/lbs_d_o__01__main__initialize_8cc.html#adfad77f405a91e0c24b4bed78523652d">SweepChunk</a>,&amp;xs]()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d=0; d&lt;num_dirs; ++d)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;omega = quadrature-&gt;omegas[d];</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;weight = quadrature-&gt;weights[d];</div>
<div class="line"> </div>
<div class="line">      std::vector&lt;int64_t&gt; iorder, jorder, korder;</div>
<div class="line">      <span class="keywordflow">if</span> (omega.x &gt; 0.0) iorder = chi_math::Range&lt;int64_t&gt;(0, Nx);</div>
<div class="line">      <span class="keywordflow">else</span>               iorder = chi_math::Range&lt;int64_t&gt;(Nx - 1, -1, -1);</div>
<div class="line">      <span class="keywordflow">if</span> (omega.y &gt; 0.0) jorder = chi_math::Range&lt;int64_t&gt;(0, Ny);</div>
<div class="line">      <span class="keywordflow">else</span>               jorder = chi_math::Range&lt;int64_t&gt;(Ny - 1, -1, -1);</div>
<div class="line">      <span class="keywordflow">if</span> (omega.z &gt; 0.0) korder = chi_math::Range&lt;int64_t&gt;(0, Nz);</div>
<div class="line">      <span class="keywordflow">else</span>               korder = chi_math::Range&lt;int64_t&gt;(Nz - 1, -1, -1);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i: iorder)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> j: jorder)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keyword">auto</span> k: korder)</div>
<div class="line">            <a class="code hl_typedef" href="../../d9/df7/lbs_d_o__01__main__initialize_8cc.html#adfad77f405a91e0c24b4bed78523652d">SweepChunk</a>({i,j,k}, omega, d, xs);</div>
<div class="line">    }<span class="comment">//for d</span></div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Classic Richardson iteration</span></div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Starting iterations&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iter=0; iter&lt;200; ++iter)</div>
<div class="line">  {</div>
<div class="line">    phi_new.assign(phi_new.size(), 0.0);</div>
<div class="line">    <span class="comment">//Build rhs</span></div>
<div class="line">    source_moments = <a class="code hl_function" href="../../d0/d68/namespacechi__unit__sim__tests.html#a15826c4853d6ae31074cfd0901702d69">SetSource</a>(grid, sdm, phi_uk_man,</div>
<div class="line">                               q_source, phi_old, xs, m_ell_em_map);</div>
<div class="line">    Sweep();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> rel_change = <a class="code hl_function" href="../../d0/d68/namespacechi__unit__sim__tests.html#a4ec383a71de8faee1ccf06fc95860c3a">ComputeRelativePWChange</a>(grid, sdm, phi_uk_man,</div>
<div class="line">                                                      phi_new, phi_old);</div>
<div class="line"> </div>
<div class="line">    std::stringstream outstr;</div>
<div class="line">    outstr &lt;&lt; <span class="stringliteral">&quot;Iteration &quot;</span> &lt;&lt; std::setw(5) &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">char</span> buffer[100];</div>
<div class="line">      sprintf(buffer, <span class="stringliteral">&quot;%11.3e\n&quot;</span>, rel_change);</div>
<div class="line">      outstr &lt;&lt; buffer;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    chi::log.Log() &lt;&lt; outstr.str();</div>
<div class="line"> </div>
<div class="line">    phi_old = phi_new;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (rel_change &lt; 1.0e-6 and iter &gt; 0)</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }<span class="comment">//for iteration</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Localize zeroth moment</span></div>
<div class="line">  <span class="comment">//This routine extracts a single moment vector</span></div>
<div class="line">  <span class="comment">//from the vector that contains multiple moments</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="../../d9/da7/classchi__math_1_1_unknown_manager.html">chi_math::UnknownManager</a> m0_uk_man(</div>
<div class="line">    {<a class="code hl_class" href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a>(<a class="code hl_enumvalue" href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1dad7dc5b5f08aa4bc980c2f7e92a9046d4">chi_math::UnknownType::VECTOR_N</a>,num_groups)});</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_m0_dofs = sdm.GetNumLocalDOFs(m0_uk_man);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;double&gt; m0_phi(num_m0_dofs, 0.0);</div>
<div class="line"> </div>
<div class="line">  sdm.CopyVectorWithUnknownScope(phi_old,     <span class="comment">//from vector</span></div>
<div class="line">                                 m0_phi,      <span class="comment">//to vector</span></div>
<div class="line">                                 phi_uk_man,  <span class="comment">//from dof-structure</span></div>
<div class="line">                                 0,           <span class="comment">//from unknown-id</span></div>
<div class="line">                                 m0_uk_man,   <span class="comment">//to dof-structure</span></div>
<div class="line">                                 0);          <span class="comment">//to unknown-id</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Create Field Function</span></div>
<div class="line">  <span class="keyword">auto</span> phi_ff = std::make_shared&lt;chi_physics::FieldFunction&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;Phi&quot;</span>,                                           <span class="comment">//Text name</span></div>
<div class="line">    sdm_ptr,                                         <span class="comment">//Spatial Discr.</span></div>
<div class="line">    <a class="code hl_class" href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a>(<a class="code hl_enumvalue" href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1dad7dc5b5f08aa4bc980c2f7e92a9046d4">chi_math::UnknownType::VECTOR_N</a>,num_groups) <span class="comment">//Unknown</span></div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  phi_ff-&gt;UpdateFieldVector(m0_phi);</div>
<div class="line">  phi_ff-&gt;ExportToVTK(<span class="stringliteral">&quot;SimTest_06_WDD&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  chi::Finalize();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aangular__product__quadrature_8h_html"><div class="ttname"><a href="../../da/daf/angular__product__quadrature_8h.html">angular_product_quadrature.h</a></div></div>
<div class="ttc" id="aangular__quadrature__base_8h_html"><div class="ttname"><a href="../../d5/d27/angular__quadrature__base_8h.html">angular_quadrature_base.h</a></div></div>
<div class="ttc" id="achi__log_8h_html"><div class="ttname"><a href="../../dc/d75/chi__log_8h.html">chi_log.h</a></div></div>
<div class="ttc" id="achi__math__range_8h_html"><div class="ttname"><a href="../../d4/d1c/chi__math__range_8h.html">chi_math_range.h</a></div></div>
<div class="ttc" id="achi__meshcontinuum_8h_html"><div class="ttname"><a href="../../d0/db3/chi__meshcontinuum_8h.html">chi_meshcontinuum.h</a></div></div>
<div class="ttc" id="achi__meshhandler_8h_html"><div class="ttname"><a href="../../df/d98/chi__meshhandler_8h.html">chi_meshhandler.h</a></div></div>
<div class="ttc" id="achi__runtime_8h_html"><div class="ttname"><a href="../../d3/db2/chi__runtime_8h.html">chi_runtime.h</a></div></div>
<div class="ttc" id="achi__tech__main_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="../../d4/dca/chi__tech__main_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/chi__tech__main_8cc_source.html#l00010">chi_tech_main.cc:10</a></div></div>
<div class="ttc" id="aclasschi__math_1_1_spatial_discretization___f_v_html_aef2abe8e2064b84e29d87a2b2b2f984d"><div class="ttname"><a href="../../d0/d9a/classchi__math_1_1_spatial_discretization___f_v.html#aef2abe8e2064b84e29d87a2b2b2f984d">chi_math::SpatialDiscretization_FV::New</a></div><div class="ttdeci">static std::shared_ptr&lt; SpatialDiscretization_FV &gt; New(const chi_mesh::MeshContinuum &amp;in_grid, CoordinateSystemType in_cs_type=CoordinateSystemType::CARTESIAN)</div><div class="ttdef"><b>Definition:</b> <a href="../../d9/d77/fv__00__constrdestr_8cc_source.html#l00021">fv_00_constrdestr.cc:21</a></div></div>
<div class="ttc" id="aclasschi__math_1_1_spatial_discretization_html_a04c0c7022de9c74ac6a807398afec030"><div class="ttname"><a href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#a04c0c7022de9c74ac6a807398afec030">chi_math::SpatialDiscretization::GetNumGlobalDOFs</a></div><div class="ttdeci">virtual size_t GetNumGlobalDOFs(const UnknownManager &amp;unknown_manager) const =0</div></div>
<div class="ttc" id="aclasschi__math_1_1_spatial_discretization_html_ab44301c258e4b6921f7afad19e355746"><div class="ttname"><a href="../../dd/d1d/classchi__math_1_1_spatial_discretization.html#ab44301c258e4b6921f7afad19e355746">chi_math::SpatialDiscretization::UNITARY_UNKNOWN_MANAGER</a></div><div class="ttdeci">const UnknownManager UNITARY_UNKNOWN_MANAGER</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d28/spatial__discretization_8h_source.html#l00026">spatial_discretization.h:26</a></div></div>
<div class="ttc" id="aclasschi__mesh_1_1_mesh_continuum_html_a15eed36e4da5d55ac9ad26d6a37a7a72"><div class="ttname"><a href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a15eed36e4da5d55ac9ad26d6a37a7a72">chi_mesh::MeshContinuum::Attributes</a></div><div class="ttdeci">MeshAttributes Attributes() const</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/db3/chi__meshcontinuum_8h_source.html#l00134">chi_meshcontinuum.h:134</a></div></div>
<div class="ttc" id="aclasschi__mesh_1_1_mesh_continuum_html_a5cb74fab0769b9fda964b5429623d04a"><div class="ttname"><a href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a5cb74fab0769b9fda964b5429623d04a">chi_mesh::MeshContinuum::GetIJKInfo</a></div><div class="ttdeci">std::array&lt; size_t, 3 &gt; GetIJKInfo() const</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d61/chi__meshcontinuum__utilities_8cc_source.html#l00396">chi_meshcontinuum_utilities.cc:396</a></div></div>
<div class="ttc" id="aclasschi__mesh_1_1_mesh_continuum_html_a66224c8024c8e1e395389dd8ccd547c1"><div class="ttname"><a href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a66224c8024c8e1e395389dd8ccd547c1">chi_mesh::MeshContinuum::MakeCellOrthoSizes</a></div><div class="ttdeci">std::vector&lt; chi_mesh::Vector3 &gt; MakeCellOrthoSizes() const</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d61/chi__meshcontinuum__utilities_8cc_source.html#l00433">chi_meshcontinuum_utilities.cc:433</a></div></div>
<div class="ttc" id="aclasschi__mesh_1_1_mesh_continuum_html_a6ff14aae03e8c78ca276c9f2884bcd98"><div class="ttname"><a href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#a6ff14aae03e8c78ca276c9f2884bcd98">chi_mesh::MeshContinuum::MakeIJKToGlobalIDMapping</a></div><div class="ttdeci">chi_data_types::NDArray&lt; uint64_t &gt; MakeIJKToGlobalIDMapping() const</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d61/chi__meshcontinuum__utilities_8cc_source.html#l00408">chi_meshcontinuum_utilities.cc:408</a></div></div>
<div class="ttc" id="aclasschi__mesh_1_1_mesh_continuum_html_aeb466c76d1b4d532fe8bc5fc7765a338"><div class="ttname"><a href="../../d3/d1c/classchi__mesh_1_1_mesh_continuum.html#aeb466c76d1b4d532fe8bc5fc7765a338">chi_mesh::MeshContinuum::GetGlobalNumberOfCells</a></div><div class="ttdeci">size_t GetGlobalNumberOfCells() const</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d01/chi__meshcontinuum__globalcellhandler_8cc_source.html#l00085">chi_meshcontinuum_globalcellhandler.cc:85</a></div></div>
<div class="ttc" id="aclasschi__mesh_1_1_mesh_handler_html_aa87887c1a76634cb07134b5faa1e3587"><div class="ttname"><a href="../../d2/d10/classchi__mesh_1_1_mesh_handler.html#aa87887c1a76634cb07134b5faa1e3587">chi_mesh::MeshHandler::GetGrid</a></div><div class="ttdeci">chi_mesh::MeshContinuumPtr &amp; GetGrid() const</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d65/chi__meshhandler_8cc_source.html#l00012">chi_meshhandler.cc:12</a></div></div>
<div class="ttc" id="afv_8h_html"><div class="ttname"><a href="../../de/d50/fv_8h.html">fv.h</a></div></div>
<div class="ttc" id="anamespacechi__math_html_ab6754b3179f7dbf965932210273fead7"><div class="ttname"><a href="../../dc/d58/namespacechi__math.html#ab6754b3179f7dbf965932210273fead7">chi_math::SDMPtr</a></div><div class="ttdeci">std::shared_ptr&lt; SpatialDiscretization &gt; SDMPtr</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/df1/cfem__diffusion__solver_8h_source.html#l00025">cfem_diffusion_solver.h:24</a></div></div>
<div class="ttc" id="anamespacechi__mesh_html_addcd6899961d4c527b02c33708a7941f"><div class="ttname"><a href="../../d0/d81/namespacechi__mesh.html#addcd6899961d4c527b02c33708a7941f">chi_mesh::GetCurrentHandler</a></div><div class="ttdeci">MeshHandler &amp; GetCurrentHandler()</div><div class="ttdef"><b>Definition:</b> <a href="../../de/d4b/chi__mesh__meshhandler__utils_8cc_source.html#l00013">chi_mesh_meshhandler_utils.cc:13</a></div></div>
<div class="ttc" id="andarray_8h_html"><div class="ttname"><a href="../../de/d01/ndarray_8h.html">ndarray.h</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Chi-Tech</a></li><li class="navelem"><a class="el" href="../../d7/db6/_programmer_manual.html">Developer&#39;s manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
