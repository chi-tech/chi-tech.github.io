<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chi-Tech: Coding Tutorial 3 - Poisson&#39;s problem with PWLC</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../Logo2_Small.bmp"/></td>
  <td id="projectalign">
   <div id="projectname">Chi-Tech
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d1/d74/_code_tut3.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Coding Tutorial 3 - Poisson's problem with PWLC </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Table of contents</h2>
<ul>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec1">1 Poisson's equation</a><ul>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec1_1">1.1 Our specific problem</a></li>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec1_2">1.2 The Weak-form of Poisson's equation</a></li>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec1_3">1.3 The discretized equation with the Continuous Galerkin approach</a></li>
</ul>
</li>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec2">2 Setting up the problem</a></li>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec3">3 Initializing the PWLC Spatial Discretization</a></li>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec4">4 Using quadrature data to assemble the system</a></li>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec5">5 Compensating for Dirichlet boundaries</a></li>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec6">6 Solving and visualizing</a></li>
<li><a class="el" href="../../d1/d74/_code_tut3.html#CodeTut3Sec7">The complete program</a></li>
</ul>
<h1><a class="anchor" id="CodeTut3Sec1"></a>
1 Poisson's equation</h1>
<p ><a href="https://en.wikipedia.org/wiki/Poisson%27s_equation">The Poisson's equation</a> states the following, for <img class="formulaInl" alt="$ \phi, q \in \mathcal{R} $" src="../../form_116.png" width="54" height="15"/>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\boldsymbol{\nabla} \boldsymbol{\cdot} \bigr(\boldsymbol{\nabla} \phi(\mathbf{x})\bigr) = q(\mathbf{x}), \quad \quad \quad (\mathbf{x})\in\mathcal{D} \\ \phi(\mathbf{x}) = 0, \quad \quad \quad \mathbf{x}\in \partial \mathcal{D} \end{eqnarray*}" src="../../form_153.png" width="239" height="41"/>
</p>
<p> where <img class="formulaInl" alt="$ \boldsymbol{\nabla} \boldsymbol{\cdot} \bigr( \bigr) $" src="../../form_154.png" width="30" height="20"/> denotes the divergence-operator and <img class="formulaInl" alt="$ \boldsymbol{\nabla} $" src="../../form_119.png" width="14" height="14"/> denotes the gradient-operator, i.e. <img class="formulaInl" alt="$ \boldsymbol{\nabla} \phi $" src="../../form_120.png" width="23" height="15"/> denotes the gradient of <img class="formulaInl" alt="$ \phi $" src="../../form_19.png" width="9" height="15"/>. The boundary conditions here state that <img class="formulaInl" alt="$ \phi=0 $" src="../../form_121.png" width="36" height="15"/> on the boundary.</p>
<h2><a class="anchor" id="CodeTut3Sec1_1"></a>
1.1 Our specific problem</h2>
<p >For our specific problem we will choose <img class="formulaInl" alt="$ q(\mathbf{x})=1 $" src="../../form_122.png" width="54" height="17"/> and <img class="formulaInl" alt="$ \mathcal{D} $" src="../../form_123.png" width="14" height="12"/> a cartesian domain, either 1D, 2D or 3D, with each dimension always between <img class="formulaInl" alt="$ -1,+1 $" src="../../form_124.png" width="44" height="14"/>. We can generate the mesh for this problem using an input file </p><div class="fragment"><div class="line">--############################################### Setup mesh</div>
<div class="line"><a class="code hl_function" href="../../da/d92/group___lua_mesh_handler.html#ga3be36a5ecf5469ad0980dd5aa4097a2a">chiMeshHandlerCreate</a>()</div>
<div class="line"> </div>
<div class="line">mesh={}</div>
<div class="line">N=20</div>
<div class="line">L=2</div>
<div class="line">xmin = -L/2</div>
<div class="line">dx = L/N</div>
<div class="line"><span class="keywordflow">for</span> i=1,(N+1) <span class="keywordflow">do</span></div>
<div class="line">    k=i-1</div>
<div class="line">    mesh[i] = xmin + k*dx</div>
<div class="line">end</div>
<div class="line"> </div>
<div class="line">--<a class="code hl_function" href="../../d9/db8/group___lua_mesh_macros.html#ga12dcd80ee2ab6104ba6e7142d7885221">chiMeshCreateUnpartitioned3DOrthoMesh</a>(mesh,mesh,mesh)</div>
<div class="line"><a class="code hl_function" href="../../d9/db8/group___lua_mesh_macros.html#ga83d9d3e4a7ae7060391faefe17c1076a">chiMeshCreateUnpartitioned2DOrthoMesh</a>(mesh,mesh)</div>
<div class="line">--<a class="code hl_function" href="../../d9/db8/group___lua_mesh_macros.html#gabcd0e135b1081c3b9eb6661d44fb21d7">chiMeshCreateUnpartitioned1DOrthoMesh</a>(mesh)</div>
<div class="line"><a class="code hl_function" href="../../d4/d3a/group___lua_volume_mesher.html#gad031f7f22f9a1b4d7ea535f04c56ae1f">chiVolumeMesherExecute</a>();</div>
<div class="line"> </div>
<div class="line">--############################################### <a class="code hl_function" href="../../dc/d58/namespacechi__math.html#a75948cb3d263fe5216470bae075742ea">Set</a> Material IDs</div>
<div class="line"><a class="code hl_function" href="../../d4/d3a/group___lua_volume_mesher.html#ga88fb27136bed385ee1ec665d8d2e9e63">chiVolumeMesherSetMatIDToAll</a>(0)</div>
<div class="ttc" id="agroup___lua_mesh_handler_html_ga3be36a5ecf5469ad0980dd5aa4097a2a"><div class="ttname"><a href="../../da/d92/group___lua_mesh_handler.html#ga3be36a5ecf5469ad0980dd5aa4097a2a">chi_lua::chiMeshHandlerCreate</a></div><div class="ttdeci">Handle chiMeshHandlerCreate()</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d47/lua__functions_8c_source.html#l01180">lua_functions.c:1180</a></div></div>
<div class="ttc" id="agroup___lua_mesh_macros_html_ga12dcd80ee2ab6104ba6e7142d7885221"><div class="ttname"><a href="../../d9/db8/group___lua_mesh_macros.html#ga12dcd80ee2ab6104ba6e7142d7885221">chi_lua::chiMeshCreateUnpartitioned3DOrthoMesh</a></div><div class="ttdeci">Two chiMeshCreateUnpartitioned3DOrthoMesh(array_float x_nodes, array_float y_nodes, array_float z_nodes)</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d47/lua__functions_8c_source.html#l02649">lua_functions.c:2649</a></div></div>
<div class="ttc" id="agroup___lua_mesh_macros_html_ga83d9d3e4a7ae7060391faefe17c1076a"><div class="ttname"><a href="../../d9/db8/group___lua_mesh_macros.html#ga83d9d3e4a7ae7060391faefe17c1076a">chi_lua::chiMeshCreateUnpartitioned2DOrthoMesh</a></div><div class="ttdeci">Two chiMeshCreateUnpartitioned2DOrthoMesh(array_float x_nodes, array_float y_nodes)</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d47/lua__functions_8c_source.html#l02600">lua_functions.c:2600</a></div></div>
<div class="ttc" id="agroup___lua_mesh_macros_html_gabcd0e135b1081c3b9eb6661d44fb21d7"><div class="ttname"><a href="../../d9/db8/group___lua_mesh_macros.html#gabcd0e135b1081c3b9eb6661d44fb21d7">chi_lua::chiMeshCreateUnpartitioned1DOrthoMesh</a></div><div class="ttdeci">Two chiMeshCreateUnpartitioned1DOrthoMesh(array_float x_nodes)</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d47/lua__functions_8c_source.html#l02526">lua_functions.c:2526</a></div></div>
<div class="ttc" id="agroup___lua_volume_mesher_html_ga88fb27136bed385ee1ec665d8d2e9e63"><div class="ttname"><a href="../../d4/d3a/group___lua_volume_mesher.html#ga88fb27136bed385ee1ec665d8d2e9e63">chi_lua::chiVolumeMesherSetMatIDToAll</a></div><div class="ttdeci">void chiVolumeMesherSetMatIDToAll(int material_id)</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d47/lua__functions_8c_source.html#l01963">lua_functions.c:1963</a></div></div>
<div class="ttc" id="agroup___lua_volume_mesher_html_gad031f7f22f9a1b4d7ea535f04c56ae1f"><div class="ttname"><a href="../../d4/d3a/group___lua_volume_mesher.html#gad031f7f22f9a1b4d7ea535f04c56ae1f">chi_lua::chiVolumeMesherExecute</a></div><div class="ttdeci">void chiVolumeMesherExecute()</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d47/lua__functions_8c_source.html#l02053">lua_functions.c:2053</a></div></div>
<div class="ttc" id="anamespacechi__math_html_a75948cb3d263fe5216470bae075742ea"><div class="ttname"><a href="../../dc/d58/namespacechi__math.html#a75948cb3d263fe5216470bae075742ea">chi_math::Set</a></div><div class="ttdeci">void Set(VecDbl &amp;x, const double &amp;val)</div><div class="ttdef"><b>Definition:</b> <a href="../../d9/d89/chi__math__03__vector__operations_8cc_source.html#l00023">chi_math_03_vector_operations.cc:23</a></div></div>
</div><!-- fragment --><p> This code can be used to generate any of the following meshes, </p><div class="image">
<img src="../../OrthoMesh_1D_2D_3D.png" alt="" width="1200px"/>
<div class="caption">
[From left to right] 1D, 2D, 3D orthogonal mesh</div></div>
<h2><a class="anchor" id="CodeTut3Sec1_2"></a>
1.2 The Weak-form of Poisson's equation</h2>
<p >When using the finite element method we develop the so-called weak-form by weighting the Poisson equation with a trial space function, <img class="formulaInl" alt="$ t_i(\mathbf{x}) $" src="../../form_155.png" width="32" height="17"/>, where <img class="formulaInl" alt="$ i $" src="../../form_156.png" width="6" height="11"/> is a unique node in the problem, and then integrate over the volume of the domain </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\int_V t_i \boldsymbol{\nabla} \boldsymbol{\cdot} \bigr(\boldsymbol{\nabla} \phi(\mathbf{x})\bigr) dV = \int_V t_i q(\mathbf{x}) dV. \]" src="../../form_157.png" width="242" height="36"/>
</p>
<p >Next we apply integration by parts to the left term, for which, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ t_i \boldsymbol{\nabla} \boldsymbol{\cdot} \bigr(\boldsymbol{\nabla} \phi(\mathbf{x})\bigr) = \boldsymbol{\nabla} \cdot (t_i \boldsymbol{\nabla} \phi) - (\boldsymbol{\nabla} t_i ) \boldsymbol{\cdot} (\boldsymbol{\nabla} \phi) \]" src="../../form_158.png" width="278" height="20"/>
</p>
<p> which gives </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_V (\boldsymbol{\nabla} t_i ) \boldsymbol{\cdot} (\boldsymbol{\nabla} \phi) dV -\int_V \boldsymbol{\nabla} \boldsymbol{\cdot} (t_i \boldsymbol{\nabla} \phi) dV = \int_V t_i q(\mathbf{x}) dV. \]" src="../../form_159.png" width="353" height="36"/>
</p>
<p >We then apply Gauss's Divergence Theorem to the second term from the left, to get </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_V (\boldsymbol{\nabla} t_i ) \boldsymbol{\cdot} (\boldsymbol{\nabla} \phi) dV -\int_S \mathbf{n} \boldsymbol{\cdot} (t_i \boldsymbol{\nabla} \phi) dA = \int_V t_i q(\mathbf{x}) dV. \]" src="../../form_160.png" width="344" height="36"/>
</p>
<p >This is essentially the weak-form.</p>
<h2><a class="anchor" id="CodeTut3Sec1_3"></a>
1.3 The discretized equation with the Continuous Galerkin approach</h2>
<p >To fully discretize this equation we next approximate the continuous nature of <img class="formulaInl" alt="$ \phi(\mathbf{x}) $" src="../../form_161.png" width="29" height="17"/> using essentially a very fancy interpolation scheme. With this scheme we approximate <img class="formulaInl" alt="$ \phi(\mathbf{x}) $" src="../../form_161.png" width="29" height="17"/> as <img class="formulaInl" alt="$ \phi_h(\mathbf{x}) $" src="../../form_162.png" width="36" height="17"/> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phi(\mathbf{x}) \approx \phi_h(\mathbf{x}) = \sum_j \phi_j b_j(\mathbf{x}) \]" src="../../form_163.png" width="179" height="35"/>
</p>
<p> where the coefficients <img class="formulaInl" alt="$ \phi_j $" src="../../form_164.png" width="14" height="17"/> do not dependent on space and <img class="formulaInl" alt="$ b_j(\mathbf{x}) $" src="../../form_165.png" width="32" height="17"/> are called shape functions. For this tutorial we will be utilizing the Piecewise Linear Continuous (PWLC) shape functions which are generally specially in the fact that they can support arbitrary polygons and polyhedra.</p>
<p >We will also follow a Galerkin approach, resulting in the trial-functions <img class="formulaInl" alt="$ t_i $" src="../../form_166.png" width="11" height="14"/> being the same as the shape functions, i.e., <img class="formulaInl" alt="$ t_n(\mathbf{x}) = b_n(\mathbf{x}) $" src="../../form_167.png" width="90" height="17"/>.</p>
<p >With this approximation defined, our weak form, after neglecting the surface integral since we have Dirichlet boundary conditions, becomes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \int_V (\boldsymbol{\nabla} b_i ) \boldsymbol{\cdot} (\boldsymbol{\nabla} \phi) dV &amp;= \int_V b_i q(\mathbf{x}) dV \\ \sum_j \phi_j \int_V (\boldsymbol{\nabla} b_i ) \boldsymbol{\cdot} (\boldsymbol{\nabla} b_j) dV &amp;= \int_V b_i q(\mathbf{x}) dV \end{align*}" src="../../form_168.png" width="269" height="83"/>
</p>
<p >Now we are faced with the dilemma of how to compute the integral terms in this equation. The first thing we do here is to observe that the shape functions <img class="formulaInl" alt="$ b_n $" src="../../form_169.png" width="14" height="15"/> are defined cell-by-cell, therefore we can drill a little deeper by defining </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \int_V f(\mathbf{x}) dV &amp;= \sum_c \int_{V_c} f_c(\mathbf{x}) dV \\ \end{align*}" src="../../form_170.png" width="194" height="39"/>
</p>
<p> where <img class="formulaInl" alt="$ V_c $" src="../../form_171.png" width="14" height="15"/> is the volume of cell <img class="formulaInl" alt="$ c $" src="../../form_172.png" width="6" height="8"/>. The function <img class="formulaInl" alt="$ f_c $" src="../../form_173.png" width="14" height="15"/> is a function uniquely defined within cell <img class="formulaInl" alt="$ c $" src="../../form_172.png" width="6" height="8"/>'s volume.</p>
<p >These integrals are often difficult to perform in real-world coordinates and are therefore carried out on a reference element in a different coordinate system. This necessitates the use of a transformation using the magnitude of the Jacobian that transforms the above integrals into the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \int_{V_c} f_c(\mathbf{x}) dV &amp;= \int_{V_e} f_e(\tilde{\mathbf{x}}) |J(\tilde{\mathbf{x}})| dV \end{align*}" src="../../form_174.png" width="215" height="38"/>
</p>
<p> where <img class="formulaInl" alt="$ \tilde{\mathbf{x}} $" src="../../form_175.png" width="11" height="12"/> is position in the reference coordinate frame, <img class="formulaInl" alt="$|J(\tilde{\mathbf{x}})| $" src="../../form_176.png" width="38" height="17"/> is the magnitude of the Jacobian, <img class="formulaInl" alt="$ V_e $" src="../../form_177.png" width="14" height="15"/> is the volume of the reference element, and <img class="formulaInl" alt="$ f_e $" src="../../form_178.png" width="14" height="15"/> is the reference element equivalent of <img class="formulaInl" alt="$ f_c $" src="../../form_173.png" width="14" height="15"/>. Now, the big advantage of doing this is that we can use quadrature rules for these integrals </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \int_{V_e} f_e(\tilde{\mathbf{x}}) |J(\tilde{\mathbf{x}})| dV &amp;= \sum_n w_n f_e(\tilde{\mathbf{x}}_n) |J(\tilde{\mathbf{x}}_n)| \end{align*}" src="../../form_179.png" width="269" height="39"/>
</p>
<p> where <img class="formulaInl" alt="$ \tilde{\mathbf{x}}_n $" src="../../form_180.png" width="18" height="15"/> are the abscissas of the quadrature rule and <img class="formulaInl" alt="$ w_n $" src="../../form_181.png" width="20" height="11"/> are the quadrature weights.</p>
<p >With these mathematical formulations defined we can write </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_j \phi_j \sum_c \sum_n^{N_V} \biggr[ w_n (\boldsymbol{\nabla} b_i(\tilde{\mathbf{x}}_n) ) \boldsymbol{\cdot} (\boldsymbol{\nabla} b_j(\tilde{\mathbf{x}}_n)) |J(\tilde{\mathbf{x}}_n)| \biggr] &amp;= \sum_c \sum_n^{N_V} w_n b_i(\tilde{\mathbf{x}}_n) q(\tilde{\mathbf{x}}_n \to \mathbf{x}) |J(\tilde{\mathbf{x}}_n)| \end{align*}" src="../../form_182.png" width="555" height="48"/>
</p>
<h1><a class="anchor" id="CodeTut3Sec2"></a>
2 Setting up the problem</h1>
<p >For this tutorial we basically follow the flow of <a class="el" href="../../dc/da4/_code_tut1.html">Coding Tutorial 1 - Poisson's problem with Finite Volume</a>. Make sure you make sensible changes to the <code>CMakeLists.txt</code> file and name your source file appropriately, which for me is <code>code_tut3.cc</code>.</p>
<p >The first portion of the tutorial is the same. We create a <code>mesh.lua</code> file in the <code>chi_build</code> directory. We get the grid </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../d4/dca/chi__tech__main_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  chi::Initialize(argc,argv);</div>
<div class="line">  chi::RunBatch(argc, argv);</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Coding Tutorial 3&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Get grid</span></div>
<div class="line">  <span class="keyword">auto</span> grid_ptr = <a class="code hl_function" href="../../d0/d81/namespacechi__mesh.html#addcd6899961d4c527b02c33708a7941f">chi_mesh::GetCurrentHandler</a>().<a class="code hl_function" href="../../d2/d10/classchi__mesh_1_1_mesh_handler.html#aa87887c1a76634cb07134b5faa1e3587">GetGrid</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; grid = *grid_ptr;</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Global num cells: &quot;</span> &lt;&lt; grid.GetGlobalNumberOfCells();</div>
<div class="ttc" id="achi__tech__main_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="../../d4/dca/chi__tech__main_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/chi__tech__main_8cc_source.html#l00010">chi_tech_main.cc:10</a></div></div>
<div class="ttc" id="aclasschi__mesh_1_1_mesh_handler_html_aa87887c1a76634cb07134b5faa1e3587"><div class="ttname"><a href="../../d2/d10/classchi__mesh_1_1_mesh_handler.html#aa87887c1a76634cb07134b5faa1e3587">chi_mesh::MeshHandler::GetGrid</a></div><div class="ttdeci">chi_mesh::MeshContinuumPtr &amp; GetGrid() const</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d65/chi__meshhandler_8cc_source.html#l00012">chi_meshhandler.cc:12</a></div></div>
<div class="ttc" id="anamespacechi__mesh_html_addcd6899961d4c527b02c33708a7941f"><div class="ttname"><a href="../../d0/d81/namespacechi__mesh.html#addcd6899961d4c527b02c33708a7941f">chi_mesh::GetCurrentHandler</a></div><div class="ttdeci">MeshHandler &amp; GetCurrentHandler()</div><div class="ttdef"><b>Definition:</b> <a href="../../de/d4b/chi__mesh__meshhandler__utils_8cc_source.html#l00013">chi_mesh_meshhandler_utils.cc:13</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="CodeTut3Sec3"></a>
3 Initializing the PWLC Spatial Discretization</h1>
<p >To gain access to the <code><a class="el" href="../../d4/da5/classchi__math_1_1_spatial_discretization___p_w_l_c.html">chi_math::SpatialDiscretization_PWLC</a></code> class we need to include the header </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d3/dfa/pwlc_8h.html">math/SpatialDiscretization/FiniteElement/PiecewiseLinear/pwlc.h</a>&quot;</span></div>
<div class="ttc" id="apwlc_8h_html"><div class="ttname"><a href="../../d3/dfa/pwlc_8h.html">pwlc.h</a></div></div>
</div><!-- fragment --><p >Next we add the following code </p><div class="fragment"><div class="line"><span class="comment">//============================================= Make SDM</span></div>
<div class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;chi_math::SpatialDiscretization&gt; <a class="code hl_typedef" href="../../dc/d58/namespacechi__math.html#ab6754b3179f7dbf965932210273fead7">SDMPtr</a>;</div>
<div class="line"><a class="code hl_typedef" href="../../dc/d58/namespacechi__math.html#ab6754b3179f7dbf965932210273fead7">SDMPtr</a> sdm_ptr = <a class="code hl_function" href="../../d4/da5/classchi__math_1_1_spatial_discretization___p_w_l_c.html#ac5c32d8c870a1b456c9b7486dc581276">chi_math::SpatialDiscretization_PWLC::New</a>(grid_ptr);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; sdm = *sdm_ptr;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; OneDofPerNode = sdm.UNITARY_UNKNOWN_MANAGER;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_local_dofs = sdm.GetNumLocalDOFs(OneDofPerNode);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_globl_dofs = sdm.GetNumGlobalDOFs(OneDofPerNode);</div>
<div class="line"> </div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Num local DOFs: &quot;</span> &lt;&lt; num_local_dofs;</div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Num globl DOFs: &quot;</span> &lt;&lt; num_globl_dofs;</div>
<div class="ttc" id="aclasschi__math_1_1_spatial_discretization___p_w_l_c_html_ac5c32d8c870a1b456c9b7486dc581276"><div class="ttname"><a href="../../d4/da5/classchi__math_1_1_spatial_discretization___p_w_l_c.html#ac5c32d8c870a1b456c9b7486dc581276">chi_math::SpatialDiscretization_PWLC::New</a></div><div class="ttdeci">static std::shared_ptr&lt; SpatialDiscretization_PWLC &gt; New(const chi_mesh::MeshContinuum &amp;in_grid, finite_element::SetupFlags setup_flags=finite_element::NO_FLAGS_SET, QuadratureOrder qorder=QuadratureOrder::SECOND, CoordinateSystemType in_cs_type=CoordinateSystemType::CARTESIAN)</div><div class="ttdef"><b>Definition:</b> <a href="../../d1/da8/pwlc__00__constrdestr_8cc_source.html#l00085">pwlc_00_constrdestr.cc:85</a></div></div>
<div class="ttc" id="anamespacechi__math_html_ab6754b3179f7dbf965932210273fead7"><div class="ttname"><a href="../../dc/d58/namespacechi__math.html#ab6754b3179f7dbf965932210273fead7">chi_math::SDMPtr</a></div><div class="ttdeci">std::shared_ptr&lt; SpatialDiscretization &gt; SDMPtr</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/df1/cfem__diffusion__solver_8h_source.html#l00025">cfem_diffusion_solver.h:24</a></div></div>
</div><!-- fragment --><p >The initialization of the matrices and vectors remain exactly the same as in the Finite Volume tutorial: </p><div class="fragment"><div class="line"><span class="comment">//============================================= Initializes Mats and Vecs</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(num_local_dofs);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> N = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(num_globl_dofs);</div>
<div class="line">Mat A;</div>
<div class="line">Vec x,b;</div>
<div class="line"> </div>
<div class="line">A = <a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ad3c389879eeafb68d9b7540887b883cd">chi_math::PETScUtils::CreateSquareMatrix</a>(n,N);</div>
<div class="line">x = <a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ae2ebedf1cd0712f3d6e0b2047c389949">chi_math::PETScUtils::CreateVector</a>(n,N);</div>
<div class="line">b = <a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ae2ebedf1cd0712f3d6e0b2047c389949">chi_math::PETScUtils::CreateVector</a>(n,N);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;int64_t&gt; nodal_nnz_in_diag;</div>
<div class="line">std::vector&lt;int64_t&gt; nodal_nnz_off_diag;</div>
<div class="line">sdm.BuildSparsityPattern(nodal_nnz_in_diag,nodal_nnz_off_diag, OneDofPerNode);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#a1baca8287da5a48e6d56ba3da4c39bab">chi_math::PETScUtils::InitMatrixSparsity</a>(A,</div>
<div class="line">                                         nodal_nnz_in_diag,</div>
<div class="line">                                         nodal_nnz_off_diag);</div>
<div class="ttc" id="anamespacechi__math_1_1_p_e_t_sc_utils_html_a1baca8287da5a48e6d56ba3da4c39bab"><div class="ttname"><a href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#a1baca8287da5a48e6d56ba3da4c39bab">chi_math::PETScUtils::InitMatrixSparsity</a></div><div class="ttdeci">void InitMatrixSparsity(Mat &amp;A, const std::vector&lt; int64_t &gt; &amp;nodal_nnz_in_diag, const std::vector&lt; int64_t &gt; &amp;nodal_nnz_off_diag)</div><div class="ttdef"><b>Definition:</b> <a href="../../dc/d70/petsc__utils__02__create_mat_8cc_source.html#l00084">petsc_utils_02_createMat.cc:84</a></div></div>
<div class="ttc" id="anamespacechi__math_1_1_p_e_t_sc_utils_html_ad3c389879eeafb68d9b7540887b883cd"><div class="ttname"><a href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ad3c389879eeafb68d9b7540887b883cd">chi_math::PETScUtils::CreateSquareMatrix</a></div><div class="ttdeci">Mat CreateSquareMatrix(int64_t local_size, int64_t global_size)</div><div class="ttdef"><b>Definition:</b> <a href="../../dc/d70/petsc__utils__02__create_mat_8cc_source.html#l00025">petsc_utils_02_createMat.cc:25</a></div></div>
<div class="ttc" id="anamespacechi__math_1_1_p_e_t_sc_utils_html_ae2ebedf1cd0712f3d6e0b2047c389949"><div class="ttname"><a href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ae2ebedf1cd0712f3d6e0b2047c389949">chi_math::PETScUtils::CreateVector</a></div><div class="ttdeci">Vec CreateVector(int64_t local_size, int64_t global_size)</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d4d/petsc__utils__01__create_vec_8cc_source.html#l00018">petsc_utils_01_createVec.cc:19</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="CodeTut3Sec4"></a>
4 Using quadrature data to assemble the system</h1>
<p >With the finite element method the conventional way to assemble the matrix is to do so by element (even though continuous FEM is only concerned about nodes). Therefore we start with a loop over elements then assemble our discretized equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_j \phi_j \sum_c \sum_n^{N_V} \biggr[ w_n (\boldsymbol{\nabla} b_i(\tilde{\mathbf{x}}_n) ) \boldsymbol{\cdot} (\boldsymbol{\nabla} b_j(\tilde{\mathbf{x}}_n)) |J(\tilde{\mathbf{x}}_n)| \biggr] &amp;= \sum_c \sum_n^{N_V} w_n b_i(\tilde{\mathbf{x}}_n) q(\tilde{\mathbf{x}}_n \to \mathbf{x}) |J(\tilde{\mathbf{x}}_n)| \end{align*}" src="../../form_182.png" width="555" height="48"/>
</p>
<p> For which the first portion of the code is </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell : grid.local_cells)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_mapping = sdm.GetCellMapping(cell);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>  qp_data      = cell_mapping.MakeVolumeQuadraturePointData();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_nodes = cell_mapping.NumNodes();</div>
<div class="line">  <a class="code hl_typedef" href="../../d2/d08/chi__math_8h.html#a80801c4491f8f4ff54ed012d63d0d48b">MatDbl</a> Acell(num_nodes, <a class="code hl_typedef" href="../../d2/d08/chi__math_8h.html#acbe69520b2db91355c5ed8d97a218b94">VecDbl</a>(num_nodes, 0.0));</div>
<div class="line">  <a class="code hl_typedef" href="../../d2/d08/chi__math_8h.html#acbe69520b2db91355c5ed8d97a218b94">VecDbl</a> cell_rhs(num_nodes, 0.0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;num_nodes; ++j)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">double</span> entry_aij = 0.0;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> qp : qp_data.QuadraturePointIndices())</div>
<div class="line">      {</div>
<div class="line">        entry_aij +=</div>
<div class="line">          qp_data.ShapeGrad(i, qp).Dot(qp_data.ShapeGrad(j, qp)) *</div>
<div class="line">          qp_data.JxW(qp);</div>
<div class="line">      }<span class="comment">//for qp</span></div>
<div class="line">      Acell[i][j] = entry_aij;</div>
<div class="line">    }<span class="comment">//for j</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> qp : qp_data.QuadraturePointIndices())</div>
<div class="line">      cell_rhs[i] += 1.0 * qp_data.ShapeValue(i, qp) * qp_data.JxW(qp);</div>
<div class="line">  }<span class="comment">//for i</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// More code not shown</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="ttc" id="achi__math_8h_html_a80801c4491f8f4ff54ed012d63d0d48b"><div class="ttname"><a href="../../d2/d08/chi__math_8h.html#a80801c4491f8f4ff54ed012d63d0d48b">MatDbl</a></div><div class="ttdeci">std::vector&lt; VecDbl &gt; MatDbl</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d08/chi__math_8h_source.html#l00013">chi_math.h:13</a></div></div>
<div class="ttc" id="achi__math_8h_html_acbe69520b2db91355c5ed8d97a218b94"><div class="ttname"><a href="../../d2/d08/chi__math_8h.html#acbe69520b2db91355c5ed8d97a218b94">VecDbl</a></div><div class="ttdeci">std::vector&lt; double &gt; VecDbl</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d08/chi__math_8h_source.html#l00012">chi_math.h:12</a></div></div>
</div><!-- fragment --><p> The first thing we do here, as with any SD, is to grab the relevant cell mapping. After that we immediately create a <code><a class="el" href="../../d5/da1/classchi__math_1_1finite__element_1_1_internal_quadrature_point_data.html">chi_math::finite_element::InternalQuadraturePointData</a></code> with the line of code </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>  qp_data      = cell_mapping.MakeVolumeQuadraturePointData();</div>
</div><!-- fragment --><p> This data structure contains the shape function values, together with other data, pre-stored per quadrature point.</p>
<p >Next we create a local cell-matrix and local right-hand-side (RHS) which serve as lightweight proxies before we assemble relevant values into the global matrix and global RHS. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_nodes = cell_mapping.NumNodes();</div>
<div class="line"><a class="code hl_typedef" href="../../d2/d08/chi__math_8h.html#a80801c4491f8f4ff54ed012d63d0d48b">MatDbl</a> Acell(num_nodes, <a class="code hl_typedef" href="../../d2/d08/chi__math_8h.html#acbe69520b2db91355c5ed8d97a218b94">VecDbl</a>(num_nodes, 0.0));</div>
<div class="line"><a class="code hl_typedef" href="../../d2/d08/chi__math_8h.html#acbe69520b2db91355c5ed8d97a218b94">VecDbl</a> cell_rhs(num_nodes, 0.0);</div>
</div><!-- fragment --><p >We then loop over all the <img class="formulaInl" alt="$ (i,j) $" src="../../form_183.png" width="29" height="17"/> node combinations of our equation above but with scope only on the local element. Notice that we never actually pass around the actual quadrature points but rather use the quadrature point indices via <code>qp_data.QuadraturePointIndices()</code>. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;num_nodes; ++j)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">double</span> entry_aij = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> qp : qp_data.QuadraturePointIndices())</div>
<div class="line">    {</div>
<div class="line">      entry_aij +=</div>
<div class="line">        qp_data.ShapeGrad(i, qp).Dot(qp_data.ShapeGrad(j, qp)) *</div>
<div class="line">        qp_data.JxW(qp);</div>
<div class="line">    }<span class="comment">//for qp</span></div>
<div class="line">    Acell[i][j] = entry_aij;</div>
<div class="line">  }<span class="comment">//for j</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> qp : qp_data.QuadraturePointIndices())</div>
<div class="line">    cell_rhs[i] += 1.0 * qp_data.ShapeValue(i, qp) * qp_data.JxW(qp);</div>
<div class="line">}<span class="comment">//for i</span></div>
</div><!-- fragment --><p> Notice that we are actually doing </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_j \sum_n^{N_V} \biggr[ (\boldsymbol{\nabla} b_i(\tilde{\mathbf{x}}_n) ) \boldsymbol{\cdot} (\boldsymbol{\nabla} b_j(\tilde{\mathbf{x}}_n)) w_n |J(\tilde{\mathbf{x}}_n)| \biggr] \end{align*}" src="../../form_184.png" width="269" height="48"/>
</p>
<p> for cell <img class="formulaInl" alt="$ c $" src="../../form_172.png" width="6" height="8"/>, where <img class="formulaInl" alt="$ w_n |J(\tilde{\mathbf{x}}_n)| $" src="../../form_185.png" width="66" height="17"/> is combined into <code>qp_data.JxW(qp)</code>.</p>
<h1><a class="anchor" id="CodeTut3Sec5"></a>
5 Compensating for Dirichlet boundaries</h1>
<p >Dirichlet requires some special considerations. The equation for node <img class="formulaInl" alt="$ i $" src="../../form_156.png" width="6" height="11"/> essentially becomes <img class="formulaInl" alt="$ \phi_i = 0 $" src="../../form_186.png" width="41" height="15"/> for our case of zero Dirichlet boundary conditions. This essentially places just a 1 on the diagonal with no entries off-diagonal for the entire row <img class="formulaInl" alt="$ i $" src="../../form_156.png" width="6" height="11"/>. Therefore, we need to modify the local cell-matrix to reflect this situation.</p>
<p >We are unfortunately not done yet. Any row in the matrix that has an off-diaganol entry that corresponds to column <img class="formulaInl" alt="$ i $" src="../../form_156.png" width="6" height="11"/> will need to be moved to the RHS. This is because it could destroy the symmetry of an otherwise symmetric matrix.</p>
<p >We handle both these modifications in the following way. We build a flag-list for each cell node </p><div class="fragment"><div class="line">std::vector&lt;bool&gt; node_boundary_flag(num_nodes, <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> num_faces = cell.faces.size();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> f=0; f&lt;num_faces; ++f)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; face = cell.faces[f];</div>
<div class="line">  <span class="keywordflow">if</span> (face.has_neighbor) <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_face_nodes = face.vertex_ids.size();</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> fi=0; fi&lt;num_face_nodes; ++fi)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_define" href="../../d4/d44/quadrature__gausschebyshev_8cc.html#ad46b2ebcd4c426b06cda147ddc1001e7">uint</a> i = cell_mapping.MapFaceNode(f,fi);</div>
<div class="line">    node_boundary_flag[i] = <span class="keyword">true</span>;</div>
<div class="line">  }<span class="comment">//for fi</span></div>
<div class="line">}<span class="comment">//for face f</span></div>
<div class="ttc" id="aquadrature__gausschebyshev_8cc_html_ad46b2ebcd4c426b06cda147ddc1001e7"><div class="ttname"><a href="../../d4/d44/quadrature__gausschebyshev_8cc.html#ad46b2ebcd4c426b06cda147ddc1001e7">uint</a></div><div class="ttdeci">#define uint</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d44/quadrature__gausschebyshev_8cc_source.html#l00009">quadrature_gausschebyshev.cc:9</a></div></div>
</div><!-- fragment --><p> Notice the use of <code>face.has_neighbor</code> here. If the face does not have a neighbor it means the face is on a boundary and therefore a Dirichlet node. Once this condition applies we loop over the face nodes, map the face-node to a cell-node then flag that node as being on a boundary.</p>
<p >Finally, we now assemble the local cell-matrix and local RHS into the global system. </p><div class="fragment"><div class="line"><span class="comment">//======================= Assembly into system</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (node_boundary_flag[i]) <span class="comment">//if dirichlet node</span></div>
<div class="line">  {</div>
<div class="line">    MatSetValue(A, imap[i], imap[i], 1.0, ADD_VALUES);</div>
<div class="line">    VecSetValue(b, imap[i], 0.0, ADD_VALUES);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;num_nodes; ++j)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (not node_boundary_flag[j])</div>
<div class="line">        MatSetValue(A, imap[i], imap[j], Acell[i][j], ADD_VALUES);</div>
<div class="line">    }<span class="comment">//for j</span></div>
<div class="line">    VecSetValue(b, imap[i], cell_rhs[i], ADD_VALUES);</div>
<div class="line">  }</div>
<div class="line">}<span class="comment">//for i</span></div>
</div><!-- fragment --><p> We essentially loop over each node, after which we have two conditions: if the node is a boundary node then we just add an entry on the diagonal, if the node is not a boundary node we then loop over the row entries. We perform a check again to see if the j-entries are boundary nodes. If they are we put them on the RHS, if they are not then they are allowed to be matrix entries.</p>
<p >After this process we assemble the matrix and the RHS globally like we did before: </p><div class="fragment"><div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Global assembly&quot;</span>;</div>
<div class="line"> </div>
<div class="line">MatAssemblyBegin(A, MAT_FINAL_ASSEMBLY);</div>
<div class="line">MatAssemblyEnd(A, MAT_FINAL_ASSEMBLY);</div>
<div class="line">VecAssemblyBegin(b);</div>
<div class="line">VecAssemblyEnd(b);</div>
<div class="line"> </div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Done global assembly&quot;</span>;</div>
</div><!-- fragment --><h1><a class="anchor" id="CodeTut3Sec6"></a>
6 Solving and visualizing</h1>
<p >Solving the system and visualizing it is the same as was done for the Finite Volume tutorial. The matrix is still Symmetric Positive Definite (SPD) so we use the same solver/precondtioner setup. </p><div class="fragment"><div class="line"><span class="comment">//============================================= Create Krylov Solver</span></div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Solving: &quot;</span>;</div>
<div class="line"><span class="keyword">auto</span> petsc_solver =</div>
<div class="line">  <a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ab59d60d5f5daa3929e3669acdcce1b39">chi_math::PETScUtils::CreateCommonKrylovSolverSetup</a>(</div>
<div class="line">    A,               <span class="comment">//Matrix</span></div>
<div class="line">    <span class="stringliteral">&quot;PWLCDiffSolver&quot;</span>,  <span class="comment">//Solver name</span></div>
<div class="line">    KSPCG,           <span class="comment">//Solver type</span></div>
<div class="line">    PCGAMG,          <span class="comment">//Preconditioner type</span></div>
<div class="line">    1.0e-6,          <span class="comment">//Relative residual tolerance</span></div>
<div class="line">    1000);            <span class="comment">//Max iterations</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//============================================= Solve</span></div>
<div class="line">KSPSolve(petsc_solver.ksp,b,x);</div>
<div class="line"> </div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Done solving&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//============================================= Extract PETSc vector</span></div>
<div class="line">std::vector&lt;double&gt; field;</div>
<div class="line">sdm.LocalizePETScVector(x,field,OneDofPerNode);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//============================================= Clean up</span></div>
<div class="line">KSPDestroy(&amp;petsc_solver.ksp);</div>
<div class="line"> </div>
<div class="line">VecDestroy(&amp;x);</div>
<div class="line">VecDestroy(&amp;b);</div>
<div class="line">MatDestroy(&amp;A);</div>
<div class="line"> </div>
<div class="line">chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Done cleanup&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//============================================= Create Field Function</span></div>
<div class="line"><span class="keyword">auto</span> ff = std::make_shared&lt;chi_physics::FieldFunction&gt;(</div>
<div class="line">  <span class="stringliteral">&quot;Phi&quot;</span>,                                           <span class="comment">//Text name</span></div>
<div class="line">  sdm_ptr,                                         <span class="comment">//Spatial Discr.</span></div>
<div class="line">  <a class="code hl_class" href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a>(<a class="code hl_enumvalue" href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1da8f3d9a4b6a7b7f2c7afa61ca113d0db9">chi_math::UnknownType::SCALAR</a>) <span class="comment">//Unknown</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">ff-&gt;UpdateFieldVector(field);</div>
<div class="line"> </div>
<div class="line">ff-&gt;ExportToVTK(<span class="stringliteral">&quot;CodeTut3_PWLC&quot;</span>);</div>
<div class="ttc" id="aclasschi__math_1_1_unknown_html"><div class="ttname"><a href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a></div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d3b/unknown__manager_8h_source.html#l00031">unknown_manager.h:32</a></div></div>
<div class="ttc" id="anamespacechi__math_1_1_p_e_t_sc_utils_html_ab59d60d5f5daa3929e3669acdcce1b39"><div class="ttname"><a href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ab59d60d5f5daa3929e3669acdcce1b39">chi_math::PETScUtils::CreateCommonKrylovSolverSetup</a></div><div class="ttdeci">PETScSolverSetup CreateCommonKrylovSolverSetup(Mat ref_matrix, const std::string &amp;in_solver_name=&quot;KSPSolver&quot;, const std::string &amp;in_solver_type=KSPGMRES, const std::string &amp;in_preconditioner_type=PCNONE, double in_relative_residual_tolerance=1.0e-6, int64_t in_maximum_iterations=100)</div><div class="ttdef"><b>Definition:</b> <a href="../../de/da1/petsc__utils__03__create_k_s_p_8cc_source.html#l00035">petsc_utils_03_createKSP.cc:35</a></div></div>
<div class="ttc" id="anamespacechi__math_html_ad4724873fa5ae74b39c4657aa4f53d1da8f3d9a4b6a7b7f2c7afa61ca113d0db9"><div class="ttname"><a href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1da8f3d9a4b6a7b7f2c7afa61ca113d0db9">chi_math::UnknownType::SCALAR</a></div><div class="ttdeci">@ SCALAR</div></div>
</div><!-- fragment --><div class="image">
<img src="../../Tut3_Solution.png" alt="" width="900px"/>
<div class="caption">
Solution for a 2D mesh with a flat and warped view</div></div>
<h1><a class="anchor" id="CodeTut3Sec7"></a>
The complete program</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d3/db2/chi__runtime_8h.html">chi_runtime.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../dc/d75/chi__log_8h.html">chi_log.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../df/d98/chi__meshhandler_8h.html">mesh/MeshHandler/chi_meshhandler.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d3/dfa/pwlc_8h.html">math/SpatialDiscretization/FiniteElement/PiecewiseLinear/pwlc.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../da/d0e/petsc__utils_8h.html">math/PETScUtils/petsc_utils.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;physics/FieldFunction/fieldfunction2.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../d4/dca/chi__tech__main_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  chi::Initialize(argc,argv);</div>
<div class="line">  chi::RunBatch(argc, argv);</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Coding Tutorial 3&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Get grid</span></div>
<div class="line">  <span class="keyword">auto</span> grid_ptr = <a class="code hl_function" href="../../d0/d81/namespacechi__mesh.html#addcd6899961d4c527b02c33708a7941f">chi_mesh::GetCurrentHandler</a>().<a class="code hl_function" href="../../d2/d10/classchi__mesh_1_1_mesh_handler.html#aa87887c1a76634cb07134b5faa1e3587">GetGrid</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; grid = *grid_ptr;</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Global num cells: &quot;</span> &lt;&lt; grid.GetGlobalNumberOfCells();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Make SDM</span></div>
<div class="line">  <span class="keyword">typedef</span> std::shared_ptr&lt;chi_math::SpatialDiscretization&gt; <a class="code hl_typedef" href="../../dc/d58/namespacechi__math.html#ab6754b3179f7dbf965932210273fead7">SDMPtr</a>;</div>
<div class="line">  <a class="code hl_typedef" href="../../dc/d58/namespacechi__math.html#ab6754b3179f7dbf965932210273fead7">SDMPtr</a> sdm_ptr = <a class="code hl_function" href="../../d4/da5/classchi__math_1_1_spatial_discretization___p_w_l_c.html#ac5c32d8c870a1b456c9b7486dc581276">chi_math::SpatialDiscretization_PWLC::New</a>(grid_ptr);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; sdm = *sdm_ptr;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; OneDofPerNode = sdm.UNITARY_UNKNOWN_MANAGER;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_local_dofs = sdm.GetNumLocalDOFs(OneDofPerNode);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_globl_dofs = sdm.GetNumGlobalDOFs(OneDofPerNode);</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Num local DOFs: &quot;</span> &lt;&lt; num_local_dofs;</div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Num globl DOFs: &quot;</span> &lt;&lt; num_globl_dofs;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Initializes Mats and Vecs</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> n = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(num_local_dofs);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> N = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(num_globl_dofs);</div>
<div class="line">  Mat A;</div>
<div class="line">  Vec x,b;</div>
<div class="line"> </div>
<div class="line">  A = <a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ad3c389879eeafb68d9b7540887b883cd">chi_math::PETScUtils::CreateSquareMatrix</a>(n,N);</div>
<div class="line">  x = <a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ae2ebedf1cd0712f3d6e0b2047c389949">chi_math::PETScUtils::CreateVector</a>(n,N);</div>
<div class="line">  b = <a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ae2ebedf1cd0712f3d6e0b2047c389949">chi_math::PETScUtils::CreateVector</a>(n,N);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;int64_t&gt; nodal_nnz_in_diag;</div>
<div class="line">  std::vector&lt;int64_t&gt; nodal_nnz_off_diag;</div>
<div class="line">  sdm.BuildSparsityPattern(nodal_nnz_in_diag,nodal_nnz_off_diag, OneDofPerNode);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#a1baca8287da5a48e6d56ba3da4c39bab">chi_math::PETScUtils::InitMatrixSparsity</a>(A,</div>
<div class="line">                                           nodal_nnz_in_diag,</div>
<div class="line">                                           nodal_nnz_off_diag);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Assemble the system</span></div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Assembling system: &quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell : grid.local_cells)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell_mapping = sdm.GetCellMapping(cell);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>  qp_data      = cell_mapping.MakeVolumeQuadraturePointData();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_nodes = cell_mapping.NumNodes();</div>
<div class="line">    <a class="code hl_typedef" href="../../d2/d08/chi__math_8h.html#a80801c4491f8f4ff54ed012d63d0d48b">MatDbl</a> Acell(num_nodes, <a class="code hl_typedef" href="../../d2/d08/chi__math_8h.html#acbe69520b2db91355c5ed8d97a218b94">VecDbl</a>(num_nodes, 0.0));</div>
<div class="line">    <a class="code hl_typedef" href="../../d2/d08/chi__math_8h.html#acbe69520b2db91355c5ed8d97a218b94">VecDbl</a> cell_rhs(num_nodes, 0.0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;num_nodes; ++j)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordtype">double</span> entry_aij = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> qp : qp_data.QuadraturePointIndices())</div>
<div class="line">        {</div>
<div class="line">          entry_aij +=</div>
<div class="line">            qp_data.ShapeGrad(i, qp).Dot(qp_data.ShapeGrad(j, qp)) *</div>
<div class="line">            qp_data.JxW(qp);</div>
<div class="line">        }<span class="comment">//for qp</span></div>
<div class="line">        Acell[i][j] = entry_aij;</div>
<div class="line">      }<span class="comment">//for j</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> qp : qp_data.QuadraturePointIndices())</div>
<div class="line">        cell_rhs[i] += 1.0 * qp_data.ShapeValue(i, qp) * qp_data.JxW(qp);</div>
<div class="line">    }<span class="comment">//for i</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//======================= Flag nodes for being on dirichlet boundary</span></div>
<div class="line">    std::vector&lt;bool&gt; node_boundary_flag(num_nodes, <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_faces = cell.faces.size();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> f=0; f&lt;num_faces; ++f)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; face = cell.faces[f];</div>
<div class="line">      <span class="keywordflow">if</span> (face.has_neighbor) <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_face_nodes = face.vertex_ids.size();</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> fi=0; fi&lt;num_face_nodes; ++fi)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_define" href="../../d4/d44/quadrature__gausschebyshev_8cc.html#ad46b2ebcd4c426b06cda147ddc1001e7">uint</a> i = cell_mapping.MapFaceNode(f,fi);</div>
<div class="line">        node_boundary_flag[i] = <span class="keyword">true</span>;</div>
<div class="line">      }<span class="comment">//for fi</span></div>
<div class="line">    }<span class="comment">//for face f</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//======================= Develop node mapping</span></div>
<div class="line">    std::vector&lt;int64_t&gt; imap(num_nodes, 0); <span class="comment">//node-mapping</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">      imap[i] = sdm.MapDOF(cell, i);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//======================= Assembly into system</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;num_nodes; ++i)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (node_boundary_flag[i]) <span class="comment">//if dirichlet node</span></div>
<div class="line">      {</div>
<div class="line">        MatSetValue(A, imap[i], imap[i], 1.0, ADD_VALUES);</div>
<div class="line">        VecSetValue(b, imap[i], 0.0, ADD_VALUES);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;num_nodes; ++j)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">if</span> (not node_boundary_flag[j])</div>
<div class="line">            MatSetValue(A, imap[i], imap[j], Acell[i][j], ADD_VALUES);</div>
<div class="line">        }<span class="comment">//for j</span></div>
<div class="line">        VecSetValue(b, imap[i], cell_rhs[i], ADD_VALUES);</div>
<div class="line">      }</div>
<div class="line">    }<span class="comment">//for i</span></div>
<div class="line">  }<span class="comment">//for cell</span></div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Global assembly&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  MatAssemblyBegin(A, MAT_FINAL_ASSEMBLY);</div>
<div class="line">  MatAssemblyEnd(A, MAT_FINAL_ASSEMBLY);</div>
<div class="line">  VecAssemblyBegin(b);</div>
<div class="line">  VecAssemblyEnd(b);</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Done global assembly&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Create Krylov Solver</span></div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Solving: &quot;</span>;</div>
<div class="line">  <span class="keyword">auto</span> petsc_solver =</div>
<div class="line">    <a class="code hl_function" href="../../dc/d29/namespacechi__math_1_1_p_e_t_sc_utils.html#ab59d60d5f5daa3929e3669acdcce1b39">chi_math::PETScUtils::CreateCommonKrylovSolverSetup</a>(</div>
<div class="line">      A,               <span class="comment">//Matrix</span></div>
<div class="line">      <span class="stringliteral">&quot;PWLCDiffSolver&quot;</span>,  <span class="comment">//Solver name</span></div>
<div class="line">      KSPCG,           <span class="comment">//Solver type</span></div>
<div class="line">      PCGAMG,          <span class="comment">//Preconditioner type</span></div>
<div class="line">      1.0e-6,          <span class="comment">//Relative residual tolerance</span></div>
<div class="line">      1000);            <span class="comment">//Max iterations</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Solve</span></div>
<div class="line">  KSPSolve(petsc_solver.ksp,b,x);</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Done solving&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Extract PETSc vector</span></div>
<div class="line">  std::vector&lt;double&gt; field;</div>
<div class="line">  sdm.LocalizePETScVector(x,field,OneDofPerNode);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Clean up</span></div>
<div class="line">  KSPDestroy(&amp;petsc_solver.ksp);</div>
<div class="line"> </div>
<div class="line">  VecDestroy(&amp;x);</div>
<div class="line">  VecDestroy(&amp;b);</div>
<div class="line">  MatDestroy(&amp;A);</div>
<div class="line"> </div>
<div class="line">  chi::log.Log() &lt;&lt; <span class="stringliteral">&quot;Done cleanup&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//============================================= Create Field Function</span></div>
<div class="line">  <span class="keyword">auto</span> ff = std::make_shared&lt;chi_physics::FieldFunction&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;Phi&quot;</span>,                                           <span class="comment">//Text name</span></div>
<div class="line">    sdm_ptr,                                         <span class="comment">//Spatial Discr.</span></div>
<div class="line">    <a class="code hl_class" href="../../d8/df3/classchi__math_1_1_unknown.html">chi_math::Unknown</a>(<a class="code hl_enumvalue" href="../../dc/d58/namespacechi__math.html#ad4724873fa5ae74b39c4657aa4f53d1da8f3d9a4b6a7b7f2c7afa61ca113d0db9">chi_math::UnknownType::SCALAR</a>) <span class="comment">//Unknown</span></div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  ff-&gt;UpdateFieldVector(field);</div>
<div class="line"> </div>
<div class="line">  ff-&gt;ExportToVTK(<span class="stringliteral">&quot;CodeTut3_PWLC&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  chi::Finalize();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="achi__log_8h_html"><div class="ttname"><a href="../../dc/d75/chi__log_8h.html">chi_log.h</a></div></div>
<div class="ttc" id="achi__meshhandler_8h_html"><div class="ttname"><a href="../../df/d98/chi__meshhandler_8h.html">chi_meshhandler.h</a></div></div>
<div class="ttc" id="achi__runtime_8h_html"><div class="ttname"><a href="../../d3/db2/chi__runtime_8h.html">chi_runtime.h</a></div></div>
<div class="ttc" id="apetsc__utils_8h_html"><div class="ttname"><a href="../../da/d0e/petsc__utils_8h.html">petsc_utils.h</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Chi-Tech</a></li><li class="navelem"><a class="el" href="../../d7/db6/_programmer_manual.html">Developer&#39;s manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
